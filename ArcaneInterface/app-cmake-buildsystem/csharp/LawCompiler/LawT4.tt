<#@ template language="C#" #>
<#@ import namespace="System.Linq" #>
// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool. 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#ifndef ARCGEOSIM_GENERATED_<#= Model.name.ToUpper() #>_LAW_H
#define ARCGEOSIM_GENERATED_<#= Model.name.ToUpper() #>_LAW_H

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

<# if(MultiThread == MultiThreadMode.ArcaneTBB){ #>
#include <arcane/Concurrency.h>
#include <arcane/utils/PlatformUtils.h>
<# }
   if(MultiThread == MultiThreadMode.Kokkos){ #>
#include <Kokkos_Core.hpp>
<# } #>
#include "ArcGeoSim/Physics/Law2/IFunction.h"
<# if(Debug) { #>
#include <arcane/utils/ITraceMng.h>
<# } #>
<# if(Inference == InferenceMode.ONNX){ #>
#include <onnxruntime/core/session/onnxruntime_cxx_api.h>
#include<algorithm>
<# } #>
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

namespace <#= Model.name #> {

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

struct SignatureDescription
{
  struct ArgDescription {
    Arcane::String name;
    Arcane::String type;
    Arcane::String dim;
  };
  Arcane::UniqueArray<ArgDescription> inputs;
  Arcane::UniqueArray<ArgDescription> outputs;
  Arcane::UniqueArray<ArgDescription> parameters;
  SignatureDescription()
  {
<# foreach(var p in Inputs) { #>
    inputs.add({"<#= p.name #>","<#= p.type #>","<#= p.dim #>"});
<# } 
   foreach(var p in Outputs) { #>
    outputs.add({"<#= p.name #>","<#= p.type #>","<#= p.dim #>"});
<# } 
   foreach(var p in Parameters) { #>
    parameters.add({"<#= p.name #>","<#= p.type #>","<#= p.dim #>"});
<# } #>
  }
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

struct Signature
{
<# foreach(var p in AllProperties) { #>
  <#= p.Type #> <#= p.name #>;
<# } #>  
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class Function
  : public Law::IFunction
{
public:
<# if(Inference == InferenceMode.ONNX) { #>
  Function(const Signature& s, std::string& model_with_path)
    : m_signature(s)
  {
    _ckeck_signature();
    _init_onnx_session(model_with_path);
    _check_onnx_conformity();
  }
<# } else {  #>
  template<typename UserAlgo, typename Method>
  Function(const Signature& s,
           UserAlgo& kernel,
           Method method)
    : m_signature(s)
  {
    _ckeck_signature();
    
    typedef void (UserAlgo::*requiredSignature)(
      <#= Signature #>
    );

    typedef void (UserAlgo::*requiredConstSignature)(
      <#= Signature #>
    ) const;

    static_assert(
        std::is_same<Method,requiredSignature>::value ||
        std::is_same<Method,requiredConstSignature>::value,
        "Required signature and method given mismatch !!");

    m_invoker = [&,method](
      <#= CallSignature #>
    ) { (kernel.*method)(<#= ArgSignature #>); };
  }
<# } #>

  ~Function() {}

public:

  Arcane::Integer id() const { return out()[0].id(); }
  
  Arcane::String name() const { return "<#= Model.name #>"; }

  Law::PropertyVector in() const
  {
    Law::PropertyVector v;
<# foreach(var p in Inputs) { #>
    v << m_signature.<#= p.name #>;
<# } #>
    return v;
  }

  Law::PropertyVector out() const
  {
    Law::PropertyVector v;
<# foreach(var p in Outputs) { #>
    v << m_signature.<#= p.name #>;
<# } #>
    return v;
  }

  Law::PropertyVector parameters() const
  {
    Law::PropertyVector v;
<# foreach(var p in Parameters) { #>
    v << m_signature.<#= p.name #>;
<# } #>
    return v;
  }

<# if(Inference == InferenceMode.ONNX) { #>
  // Not yet differentiable
  bool isDifferentiable() const { return false; }
<# } else {  #>
  bool isDifferentiable() const { return true; }
<# } #>
  bool isParameter() const { return false; }

  const Signature& signature() { return m_signature; }
  
private:

<# if(Inference == InferenceMode.ONNX) { #>
  // onnxruntime setup environment and session
  void _init_onnx_session(std::string& model_with_path)
  {
    Ort::Env env(OrtLoggingLevel::ORT_LOGGING_LEVEL_WARNING);
    Ort::SessionOptions session_options;
    session_options.SetIntraOpNumThreads(1);
    session_options.SetGraphOptimizationLevel(GraphOptimizationLevel::ORT_ENABLE_EXTENDED);
    m_session = std::make_unique<Ort::Session>(env, model_with_path.c_str(), session_options);
  }
  
  void _check_onnx_conformity()
  {
    _check_onnx_inputs_size_and_name();
    _check_onnx_input_tensor_shape_and_type();
    _check_onnx_outputs_size_and_name();
    _check_onnx_output_tensor_shape_and_type();
  }
  
  void _check_onnx_inputs_size_and_name()
  {
    // number of inputs
    if(m_session->GetInputCount()!=1)
      throw Arcane::FatalErrorException("<#= Model.name #> onnx input size must be 1");

    // input names convention <#= inputOnnx #>
    std::string  input_name = m_session->GetInputNameAllocated(0, Ort::AllocatorWithDefaultOptions()).get();
    input_name.erase(std::remove(input_name.begin(), input_name.end(), ' '), input_name.end());
    if(input_name.compare("<#= inputOnnx #>") != 0)
      throw Arcane::FatalErrorException("<#= Model.name #> onnx input name is " + input_name + " must be <#= inputOnnx #>");
  }
  
  void _check_onnx_input_tensor_shape_and_type()
  {
    Ort::TypeInfo type_info = m_session->GetInputTypeInfo(0);
    auto tensor_info = type_info.GetTensorTypeAndShapeInfo();
    
    // tensor 3 axis
    if(tensor_info.GetDimensionsCount()!=3)
      throw Arcane::FatalErrorException("<#= Model.name #> onnx dimension must be 3");
      
    // -1 on axis 1: batch size variable, <#= Inputs.Count() #> on axis 3: number law inputs
    if(tensor_info.GetShape() != std::vector<int64_t>{ -1, 1, <#= Inputs.Count() #>} )
      throw Arcane::FatalErrorException("<#= Model.name #> onnx shape must be {-1, 1, <#= Inputs.Count() #>}");
      
    // float precision model our convention
    if(tensor_info.GetElementType()!=ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT)
      throw Arcane::FatalErrorException("<#= Model.name #> onnx element type must be float");
  }
  
  void _check_onnx_outputs_size_and_name()
  {
    // number of outputs
    if(m_session->GetOutputCount()!=1)
      throw Arcane::FatalErrorException("<#= Model.name #> onnx output size must be 1");

    // Output name: <#= outputOnnx #> our law convention
    std::string  output_name = m_session->GetOutputNameAllocated(0, Ort::AllocatorWithDefaultOptions()).get();
    output_name.erase(std::remove(output_name.begin(), output_name.end(), ' '), output_name.end());
    if(output_name.compare("<#= outputOnnx #>") != 0)
      throw Arcane::FatalErrorException("<#= Model.name #> onnx output 0 name is " + output_name + "must be <#= outputOnnx #>");
  }
  
  void _check_onnx_output_tensor_shape_and_type()
  {
    Ort::TypeInfo type_info = m_session->GetOutputTypeInfo(0);
    auto tensor_info = type_info.GetTensorTypeAndShapeInfo();
    
    // tensor 3 axis
    if(tensor_info.GetDimensionsCount()!=3)
      throw Arcane::FatalErrorException("<#= Model.name #> onnx dimension must be 3");
      
    // -1 on axis 1: batch size variable, <#= Outputs.Count() #> on axis 3: number law outputs
    if(tensor_info.GetShape() != std::vector<int64_t>{ -1, 1, <#= Outputs.Count() #>} )
      throw Arcane::FatalErrorException("<#= Model.name #> onnx shape must be {-1, 1, <#= Outputs.Count() #>}");
      
    // float precision model our convention
    if(tensor_info.GetElementType()!=ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT)
      throw Arcane::FatalErrorException("<#= Model.name #> onnx element type must be float");
  }
  
<# } #>
  void _ckeck_signature()
  {
    Law::PropertyVector v;
<# foreach(var p in InOutputs) { #>
<#   if(p.dim == PropertyDim.multiscalar) { #>
    for(auto i = 0; i < m_signature.<#= p.name #>.size(); ++i)
      _check_prop_uniq(v, m_signature.<#= p.name #>[i], "<#= p.name #>["+std::to_string(i)+"]");
<# } else { #>
    _check_prop_uniq(v, m_signature.<#= p.name #>, "<#= p.name #>");
<#   } #>
<# } #>
  }
  
  void _check_prop_uniq(Law::PropertyVector& v, const Law::Property& p, const std::string& p_name)
  {
    if(v.contains(p)) _error_signature(p_name);
    v << p;
  }
  
  void _error_signature(const std::string& prop_name)
  {
    throw Arcane::FatalErrorException(
       "<#= Model.name #>::Signature property uniqueness error, check " + prop_name + " property signature assignment"
    );
  }

public:

  void evaluate(const Law::VariableAccessor& accessor,
                const Arcane::ItemGroup& group,
                const Law::EvaluationMode mode,
                Arcane::Integer static_size = 0) const
  {
    _evaluate(mode, static_size, accessor, group);
  }

  void evaluate(const Law::PartialVariableAccessor& accessor,
                const Arcane::ItemGroup& group,
                const Law::EvaluationMode mode,
                Arcane::Integer static_size = 0) const
  {
    _evaluate(mode, static_size, accessor, group);
  }

  void evaluate(const Law::ArrayAccessor& accessor,
                const Arcane::Integer& begin,
                const Arcane::Integer& end,
                const Law::EvaluationMode mode,
                Arcane::Integer static_size = 0) const
  {
    _evaluate(mode, static_size, accessor, begin, end);
  }

  void evaluate(const Law::ScalarAccessor& accessor,
                const Law::EvaluationMode mode,
                Arcane::Integer static_size = 0) const
  {
    _evaluate(mode, static_size, accessor);
  }

private:

<# if(Inference == InferenceMode.ONNX) { #>
  void _computeOnnxInference(std::vector<float>& onnx_input_buffer, 
                             std::vector<float>& onnx_output_buffer, 
                             const int batch_size) const
  {
	// input output dims + batch size all group
    Ort::TypeInfo input_type_info = m_session->GetInputTypeInfo(0);
    auto input_tensor_info = input_type_info.GetTensorTypeAndShapeInfo();
    std::vector<int64_t> input_dims = input_tensor_info.GetShape();
    input_dims[0] = batch_size;
	
    // output dims + batch size all group
    Ort::TypeInfo output_type_info = m_session->GetOutputTypeInfo(0);
    auto output_tensor_info = output_type_info.GetTensorTypeAndShapeInfo();
    std::vector<int64_t> output_dims = output_tensor_info.GetShape();
    output_dims[0] = batch_size;
	
	// tensors creation
    std::vector<Ort::Value> input_tensors;
    std::vector<Ort::Value> output_tensors;

    Ort::MemoryInfo memory_info = Ort::MemoryInfo::CreateCpu( 
                                  OrtAllocatorType::OrtArenaAllocator, 
                                  OrtMemType::OrtMemTypeDefault);   
               
    input_tensors.push_back(Ort::Value::CreateTensor<float>(memory_info, 
                              onnx_input_buffer.data(), onnx_input_buffer.size(),
                              input_dims.data(), input_dims.size()));      
    
    output_tensors.push_back(Ort::Value::CreateTensor<float>(memory_info,
                              onnx_output_buffer.data(), onnx_output_buffer.size(), 
                              output_dims.data(), output_dims.size()));
            
    // serving names
    std::string input_name = m_session->GetInputNameAllocated(0, Ort::AllocatorWithDefaultOptions()).get();
    std::vector<const char*>  input_names{input_name.c_str()};
    std::string output_name = m_session->GetOutputNameAllocated(0, Ort::AllocatorWithDefaultOptions()).get();
    std::vector<const char*> output_names{output_name.c_str()};
    
    // model inference
    m_session->Run(Ort::RunOptions{nullptr}, 
	               input_names.data(), input_tensors.data(), 1, 
	               output_names.data(),output_tensors.data(), 1);
  }

  void _evaluateOnlyValues(const Law::VariableAccessor& accessor,
                           const Arcane::ItemGroup& group) const
  {

<# AccessGlobalValues (); #>
  
    // change to constructor for less memory create
    const int group_size = group.size();
    std::vector<float> onnx_input_buffer(<#= Inputs.Count() #>*group_size);
    std::vector<float> onnx_output_buffer(<#= Outputs.Count() #>*group_size);
    
    // copy + cast
    int in_index = 0;
    ENUMERATE_ITEM(iitem, group)
    {
<# foreach(var p in Inputs) { #>
      onnx_input_buffer[in_index++] = var_<#= p.name #>[iitem];
<# } #>
    } 

    _computeOnnxInference(onnx_input_buffer, onnx_output_buffer, group_size);
                    
    // copy onnx results into law data             
    int out_index = 0;
    ENUMERATE_ITEM(iitem, group) 
    {
<# foreach(var p in Outputs) { #>
      var_<#= p.name #>[iitem] = onnx_output_buffer[out_index++]; 
<# } #>
    }                    
  }

  void _evaluateOnlyValues(const Law::PartialVariableAccessor& accessor,
                           const Arcane::ItemGroup& group) const
  {
  
<# AccessGlobalValues (); #>

    // change to constructor for less memory create
    const int group_size = group.size();
    std::vector<float> onnx_input_buffer(<#= Inputs.Count() #>*group_size);
    std::vector<float> onnx_output_buffer(<#= Outputs.Count() #>*group_size);
    
    // copy + cast
    int in_index = 0;
    ENUMERATE_ITEM(iitem, group)
    {
<# foreach(var p in Inputs) { #>
      onnx_input_buffer[in_index++] = var_<#= p.name #>[iitem];
<# } #>
    }
 
    _computeOnnxInference(onnx_input_buffer, onnx_output_buffer, group_size);
                    
    // copy onnx results into law data             
    int out_index = 0;
    ENUMERATE_ITEM(iitem, group) 
    {
<# foreach(var p in Outputs) { #>
      var_<#= p.name #>[iitem] = onnx_output_buffer[out_index++]; 
<# } #>
    }

  }
  
  void _evaluateOnlyValues(const Law::ArrayAccessor& accessor,
                           const Arcane::Integer& begin,
                           const Arcane::Integer& end) const
  {
    // change to constructor for less memory create
    const int vector_size = end - begin;
    std::vector<float> onnx_input_buffer(<#= Inputs.Count() #>*vector_size);
    std::vector<float> onnx_output_buffer(<#= Outputs.Count() #>*vector_size);
  
<# AccessGlobalValues (); #>
    
    // copy + cast
    int in_index=0;
    for(int index = begin; index < end; ++index) {
<# foreach(var p in Inputs) { #>
    onnx_input_buffer[in_index++] = var_<#= p.name #>[index];
<# } #>
    }
    
    _computeOnnxInference(onnx_input_buffer, onnx_output_buffer, vector_size);
    
    // copy onnx results into law data
    int out_index=0;
    for(int index = begin; index < end; ++index) {
<# foreach(var p in Outputs) { #>
       var_<#= p.name #>[index] = onnx_output_buffer[out_index++];
<# } #>
    }
  }
  
  void _evaluateOnlyValues(const Law::ScalarAccessor& accessor) const
  {
    // change to constructor for less memory create
    std::vector<float> onnx_input_buffer(<#= Inputs.Count() #>);
    std::vector<float> onnx_output_buffer(<#= Outputs.Count() #>);
    
<# AccessGlobalValues (); #>
    
    // copy + cast
    int in_index=0;
<# foreach(var p in Inputs) { #>
    onnx_input_buffer[in_index++] = var_<#= p.name #>();
<# } #>
    
    _computeOnnxInference(onnx_input_buffer, onnx_output_buffer, 1);
    
    // copy onnx results into law data
    int out_index=0;
<# foreach(var p in Outputs) { #>
    var_<#= p.name #> = onnx_input_buffer[out_index++];
<# } #>

  }

<# } else { #>

  void _evaluateOnlyValues(const Law::VariableAccessor& accessor,
                           const Arcane::ItemGroup& group) const
  {
<# AccessGlobalValues (); #>
<# String groupName = "group"; #>
<# AllocateLocalData (); #>
    // Evaluation loop over items
    ENUMERATE_ITEM(iitem, <#=groupName#>) {
<# CopyGlobalValuesToLocalValues ("[iitem]"); #>
      // Invoke user kernel
      m_invoker(
        <#= InvokerCallSignature #>
      );
<# CopyLocalOutputsValuesToGlobalValues ("[iitem]"); #>
    }
  }

  void _evaluateOnlyValues(const Law::PartialVariableAccessor& accessor,
                           const Arcane::ItemGroup& group) const
  {
<# AccessGlobalValues (); #>
<# groupName = "group"; #>
<# AllocateLocalData (); #>
    // Evaluation loop over items
    ENUMERATE_ITEM(iitem, <#=groupName#>) {
<# CopyGlobalValuesToLocalValues ("[iitem]"); #>
      // Invoke user kernel
      m_invoker(
        <#= InvokerCallSignature #>
      );
<# CopyLocalOutputsValuesToGlobalValues ("[iitem]"); #>
    }
  }

  void _evaluateOnlyValues(const Law::ArrayAccessor& accessor,
                           const Arcane::Integer& begin,
                           const Arcane::Integer& end) const
  {
<# AccessGlobalValues (); #>
<# AllocateLocalData (); #>
    // Evaluation loop
    for(Arcane::Integer index = begin; index < end; ++index) {
<# CopyGlobalValuesToLocalValues ("[index]"); #>
      // Invoke user kernel
      m_invoker(
        <#= InvokerCallSignature #>
      ); 
<# CopyLocalOutputsValuesToGlobalValues ("[index]"); #>
    }
  }

  void _evaluateOnlyValues(const Law::ScalarAccessor& accessor) const
  {
<# AccessGlobalValues (); #>
<# AllocateLocalData (); #>
    {
<# CopyGlobalValuesToLocalValues ("()", true); #>
      // Invoke user kernel
      m_invoker(
        <#= InvokerCallSignature #>
      ); 
<# CopyLocalOutputsValuesToGlobalValues (""); #>
    }
  }

protected:
  void _evaluate(Arcane::Integer size,
                 const Law::VariableAccessor& accessor,
                 const Arcane::ItemGroup& group) const
  {
<# AccessGlobalValues (); #>
<# AccessGlobalDerivatives (); #>
<# ResizeGlobalDerivatives (); #>
<# groupName = "group"; #>
<# 
  
   if(MultiThread == MultiThreadMode.ArcaneTBB) { 
     groupName = "items"; #>
    auto partialEvaluateItem = [&](Arcane::ItemVectorView items) {
<# }
   else if(MultiThread == MultiThreadMode.Kokkos) {
#>
     auto group_view = group.view();
     auto partialEvaluateItem = [&](const int i) {
     auto iitem = group_view[i];
<# } #>
<# AllocateLocalData (); #>
<# CreateDerivativesOffsets (); #>
<# if(MultiThread != MultiThreadMode.Kokkos) { #>
    // Evaluation loop over items
    ENUMERATE_ITEM(iitem, <#=groupName#>) {
<# } #>
<# CopyGlobalValuesToLocalValues ("[iitem]"); #>
      // Invoke user kernel
      m_invoker(
        <#= InvokerCallSignature #>
      );
<# CopyLocalOutputsValuesToGlobalValues ("[iitem]"); #>
<# CopyLocalOutputsDerivativesToGlobalDerivatives ("[iitem]"); #>
<# if(MultiThread != MultiThreadMode.Kokkos){ #>
    }
<# } #>
<# if(MultiThread == MultiThreadMode.ArcaneTBB){ #>
    };
<# parallelEnumerate("group","partialEvaluateItem");  
  } #>
<# if(MultiThread == MultiThreadMode.Kokkos){ #>
    };
<# parallelEnumerate(Model.name, "partialEvaluateItem");  
  } #>
  }

  void _evaluate(Arcane::Integer size,
                 const Law::PartialVariableAccessor& accessor,
                 const Arcane::ItemGroup& group) const
  {
<# AccessGlobalValues (); #>
<# AccessGlobalDerivatives (); #>
<# ResizeGlobalDerivatives (); #>
<# groupName = "group"; #>
<# 
  
   if(MultiThread == MultiThreadMode.ArcaneTBB) { 
     groupName = "items"; #>
    auto partialEvaluateItem = [&](Arcane::ItemVectorView items) {
<# }
   else if(MultiThread == MultiThreadMode.Kokkos) {
#>
     auto group_view = group.view();
     auto partialEvaluateItem = [&](const int i) {
     auto iitem = group_view[i];
<# } #>
<# AllocateLocalData (); #>
<# CreateDerivativesOffsets (); #>
<# if(MultiThread != MultiThreadMode.Kokkos) { #>
    // Evaluation loop over items
    ENUMERATE_ITEM(iitem, <#=groupName#>) {
<# } #>
<# CopyGlobalValuesToLocalValues ("[iitem]"); #>
      // Invoke user kernel
      m_invoker(
        <#= InvokerCallSignature #>
      );
<# CopyLocalOutputsValuesToGlobalValues ("[iitem]"); #>
<# CopyLocalOutputsDerivativesToGlobalDerivatives ("[iitem]"); #>
<# if(MultiThread != MultiThreadMode.Kokkos){ #>
    }
<# } #>
<# if(MultiThread == MultiThreadMode.ArcaneTBB){ #>
    };
<# parallelEnumerate("group","partialEvaluateItem");  
  } #>
<# if(MultiThread == MultiThreadMode.Kokkos){ #>
    };
<# parallelEnumerate(Model.name, "partialEvaluateItem");  
  } #>
  }

  void _evaluate(Arcane::Integer size,
                 const Law::ArrayAccessor& accessor,
                 const Arcane::Integer& begin,
                 const Arcane::Integer& end) const
  {
<# AccessGlobalValues (); #>
<# AccessGlobalDerivatives (); #>
<# ResizeGlobalDerivatives (true); #>
<# AllocateLocalData (); #>
<# CreateDerivativesOffsets (); #>
    // Evaluation loop
    for(Arcane::Integer index = begin; index < end; ++index) {
<# CopyGlobalValuesToLocalValues ("[index]"); #>
      // Invoke user kernel
      m_invoker(
        <#= InvokerCallSignature #>
      );
<# CopyLocalOutputsValuesToGlobalValues ("[index]"); #>
<# CopyLocalOutputsDerivativesToGlobalDerivatives ("[index]"); #>
    }
  }

  void _evaluate(Arcane::Integer size,
                 const Law::ScalarAccessor& accessor) const
  {
<# AccessGlobalValues (); #>
<# AccessGlobalDerivatives (); #>
<# ResizeGlobalDerivatives (); #>
<# AllocateLocalData (); #>
<# CreateDerivativesOffsets (); #>
    {
<# CopyGlobalValuesToLocalValues ("()", true); #>
      // Invoke user kernel
      m_invoker(
        <#= InvokerCallSignature #>
      );
<# CopyLocalOutputsValuesToGlobalValues (""); #>
<# CopyLocalOutputsDerivativesToGlobalDerivatives (""); #>
    }
  }

<# } #>
//
// split and pass private

public:

  void derivativesCorrection(const Law::VariableAccessor& accessor,
                             const Arcane::ItemGroup& group,
                             Law::PropertyVector graph_dependencies,
                             std::map<Law::Property, Law::PropertyVector> in_composed_derivative_ofs,
                             Arcane::Integer nb_unknown_resize) const
<# if(Inference == InferenceMode.ONNX) {  #>
  {
    throw Arcane::FatalErrorException("Graph composed derivatives correction not avalaible with onnx");
  }
<# } else if(containsVectorProperty()) {  #>
  {
    throw Arcane::FatalErrorException("Graph composed derivatives correction not available with vector properties error");
  }
<# } else {  #>
  {
<# StaticGlobalDependenciesSize (); #>
<# AccessGlobalDerivatives (); #>
    // Re order derivatives and nullify before correction
    // Could be done directly in _evaluate method with offset as argument
    {
<# ComputeDerivativesReorderOffset (); #>
      //
      // Evaluation loop over items
      ENUMERATE_ITEM(iitem, group) {
<# ReorderDerivativesAndNullify ("[iitem]"); #>
      }
    }
    //
    // Derivatives correction
    Arcane::Integer direct_composed_index = nb_graph_prop - 1;
    for(auto iter_composed : in_composed_derivative_ofs)
    {
<# ComputeDerivativesCorrectionOffset (); #>
      //
      // Evaluation loop over items
      ENUMERATE_ITEM(iitem, group) {
<#  ApplyDerivativesCorrection("[iitem]"); #>
      }
    }
    //
    // Resize to root prop 
    const Arcane::Integer size = nb_unknown_resize;
<# ResizeGlobalDerivatives (); #>
  }
<# } #> 

  void derivativesCorrection(const Law::PartialVariableAccessor& accessor,
                             const Arcane::ItemGroup& group,
                             Law::PropertyVector graph_dependencies,
                             std::map<Law::Property, Law::PropertyVector> in_composed_derivative_ofs,
                             Arcane::Integer nb_unknown_resize) const
<# if(Inference == InferenceMode.ONNX) {  #>
  {
    throw Arcane::FatalErrorException("Graph composed derivatives correction not avalaible with onnx");
  }
<# } else if(containsVectorProperty()) {  #>
  {
    throw Arcane::FatalErrorException("Graph composed derivatives correction not available with vector properties error");
  }
<# } else {  #>
  {
<# StaticGlobalDependenciesSize (); #>
<# AccessGlobalDerivatives (); #>
    // Re order derivatives and nullify before correction
    // Could be done directly in _evaluate method with offset as argument
    {
<# ComputeDerivativesReorderOffset (); #>
      //
      // Evaluation loop over items
      ENUMERATE_ITEM(iitem, group) {
<# ReorderDerivativesAndNullify ("[iitem]"); #>
      }
    }
    //
    // Derivatives correction
    Arcane::Integer direct_composed_index = nb_graph_prop - 1;
    for(auto iter_composed : in_composed_derivative_ofs)
    {
<# ComputeDerivativesCorrectionOffset (); #>
      //
      // Evaluation loop over items
      ENUMERATE_ITEM(iitem, group) {
<#  ApplyDerivativesCorrection("[iitem]"); #>
      }
    }
    //
    // Resize to root prop 
    const Arcane::Integer size = nb_unknown_resize;
<# ResizeGlobalDerivatives (); #>
  }
<# } #> 

  void derivativesCorrection(const Law::ArrayAccessor& accessor,
                             const Arcane::Integer& begin,
                             const Arcane::Integer& end,
                             Law::PropertyVector graph_dependencies,
                             std::map<Law::Property, Law::PropertyVector> in_composed_derivative_ofs,
                             Arcane::Integer nb_unknown_resize) const
<# if(Inference == InferenceMode.ONNX) {  #>
  {
    throw Arcane::FatalErrorException("Graph composed derivatives correction not avalaible with onnx");
  }
<# } else if(containsVectorProperty()) {  #>
  {
    throw Arcane::FatalErrorException("Graph composed derivatives correction not available with vector properties error");
  }
<# } else {  #>
  {
<# StaticGlobalDependenciesSize (); #>
<# AccessGlobalDerivatives (); #>
    // Re order derivatives and nullify before correction
    // Could be done directly in _evaluate method with offset as argument
    {
<# ComputeDerivativesReorderOffset (); #>
      //
      // Evaluation loop
      for(Arcane::Integer i = begin; i < end; ++i) {
<# ReorderDerivativesAndNullify ("[i]"); #>
      }
    }
    //
    // Derivatives correction
    Arcane::Integer direct_composed_index = nb_graph_prop - 1;
    for(auto iter_composed : in_composed_derivative_ofs)
    {
<# ComputeDerivativesCorrectionOffset (); #>
      //
      // Evaluation loop
      for(Arcane::Integer i = begin; i < end; ++i) {
<#  ApplyDerivativesCorrection("[i]"); #>
      }
    }  
    //
    // Resize to root prop 
    const Arcane::Integer size = nb_unknown_resize;
<# ResizeGlobalDerivatives (true); #>
  }
<# } #> 

  void derivativesCorrection(const Law::ScalarAccessor& accessor,
                             Law::PropertyVector graph_dependencies,
                             std::map<Law::Property, Law::PropertyVector> in_composed_derivative_ofs,
                             Arcane::Integer nb_unknown_resize) const
<# if(Inference == InferenceMode.ONNX) {  #>
  {
    throw Arcane::FatalErrorException("Graph composed derivatives correction not avalaible with onnx");
  }
<# } else if(containsVectorProperty()) {  #>
  {
    throw Arcane::FatalErrorException("Graph composed derivatives correction not available with vector properties error");
  }
<# } else {  #>
  {
<# StaticGlobalDependenciesSize (); #>
<# AccessGlobalDerivatives (); #>
    // Re order derivatives and nullify before correction
    // Could be done directly in _evaluate method with offset as argument
    {
<# ComputeDerivativesReorderOffset (); #>
      //
      //
      {
<# ReorderDerivativesAndNullify (""); #>
      }
    }
    //
    // Derivatives correction
    Arcane::Integer direct_composed_index = nb_graph_prop - 1;
    for(auto iter_composed : in_composed_derivative_ofs)
    {
<# ComputeDerivativesCorrectionOffset (); #>
      //
      // 
      {
<#  ApplyDerivativesCorrection(""); #>
      }
    }
    //
    // Resize to root prop 
    const Arcane::Integer size = nb_unknown_resize;
<# ResizeGlobalDerivatives (); #>
  }
<# } #> 

protected:

  template<typename... T>
  void _evaluate(const Law::EvaluationMode mode, Arcane::Integer static_size, const T&... args) const
  {
<# if(Inference == InferenceMode.ONNX){ #>
    _evaluateOnlyValues(args...);
<# } else { #>
    switch(mode)
    {
    case Law::eWithoutDerivative :
      _evaluateOnlyValues(args...);
      break;
    case Law::eWithDerivative :
      if(static_size != 0) {
        _evaluate(static_size, args...);
      } else {
        _evaluate(in().dataSize(), args...);
      }
      break;
    default:
      throw Arcane::FatalErrorException("evaluation case default error");
    }
<# } #> 
  }

protected:

  Signature m_signature;
<# if(Inference == InferenceMode.ONNX){ #> 
  std::unique_ptr<Ort::Session> m_session;
<# } else { #>
  std::function<
    void(<#= Signature #>)
  > m_invoker;
<# } #>  
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
<# if(Debug) { #>
struct EpsilonDerivatives
{
<# foreach(var i in Inputs) { #>
  Arcane::Real <#= i.name #> = 1.e-6;
<# } #>
};

class DebugFunction
  : public Function
{
public:

  template<typename UserAlgo, typename Method>
  DebugFunction(const Signature& s,
                UserAlgo& kernel,
                Method method,
                const EpsilonDerivatives& epsilon,
                Arcane::ITraceMng* trace_mng):
                Function(s,kernel,method),
                m_epsilon(epsilon),
                m_trace_mng(trace_mng)
                {};

protected:
  
  void evaluate(const Law::VariableAccessor& accessor,
                const Arcane::ItemGroup& group,
                const Law::EvaluationMode mode,
                Arcane::Integer static_size = 0) const
  {
    Function::evaluate(accessor, group, mode, static_size);
<# if(Inputs.Count()>0)
   { #>
    if(mode==Law::eWithDerivative) 
      _check_derivatives(accessor, group);
<# } #>
  }
  
  void evaluate(const Law::PartialVariableAccessor& accessor,
                const Arcane::ItemGroup& group,
                const Law::EvaluationMode mode,
                Arcane::Integer static_size = 0) const
  {
    Function::evaluate(accessor, group, mode, static_size);
<# if(Inputs.Count()>0)
   { #>
    if(mode==Law::eWithDerivative) 
      _check_derivatives(accessor, group);
<# } #>
  }
  
  void evaluate(const Law::ArrayAccessor& accessor,
                const Arcane::Integer& begin,
                const Arcane::Integer& end,
                const Law::EvaluationMode mode,
                Arcane::Integer static_size = 0) const
  {
    Function::evaluate(accessor, begin, end, mode, static_size);
<# if(Inputs.Count()>0)
   { #>
    if(mode==Law::eWithDerivative) 
      _check_derivatives(accessor,  begin, end);
<# } #>
  }
  
  void evaluate(const Law::ScalarAccessor& accessor,
                const Law::EvaluationMode mode,
                Arcane::Integer static_size = 0) const
  {
    Function::evaluate(accessor, mode, static_size);
<# if(Inputs.Count()>0)
   { #>
    if(mode==Law::eWithDerivative) 
      _check_derivatives(accessor);
<# } #>
  }

<# if(Inputs.Count()>0)
   { #>
private:

  void _check_derivatives(const Law::VariableAccessor& accessor,
                          const Arcane::ItemGroup& group) const
  {
<# AccessGlobalValues (); #>
<# AccessGlobalDerivatives (); #>
<# AllocateLocalData (); #>
<# AllocateLocalDataFiniteDiff (); #>
<# CreateDerivativesOffsets (); #>
    m_trace_mng->info()<<"<#= Model.name #>"<< " debug evaluation";
    m_trace_mng->info()<<"Check consistency between law derivatives and finite difference ones";
    // Evaluation loop over items
    ENUMERATE_ITEM(iitem, group) {
<# CopyGlobalValuesToLocalValues ("[iitem]"); #>
<# CopyGlobalValuesOutputToLocalValues ("[iitem]"); #>
<# ComputeDifferenceFiniteDerivatives(); #>
<# PrintDebugValuesInfos ("[iitem]"); #>
<# PrintDebugDerivativesInfos ("[iitem]"); #>
<# CopyLocalOutputsDerivativesDiffToGlobalDerivatives ("[iitem]"); #>
    }
  }
  
  void _check_derivatives(const Law::PartialVariableAccessor& accessor,
                          const Arcane::ItemGroup& group) const
  {
<# AccessGlobalValues (); #>
<# AccessGlobalDerivatives (); #>
<# AllocateLocalData (); #>
<# AllocateLocalDataFiniteDiff (); #>
<# CreateDerivativesOffsets (); #>
    m_trace_mng->info()<<"<#= Model.name #>"<< " debug evaluation";
    m_trace_mng->info()<<"Check consistency between law derivatives and finite difference ones";
    // Evaluation loop over items
    ENUMERATE_ITEM(iitem, group) {
<# CopyGlobalValuesToLocalValues ("[iitem]"); #>
<# CopyGlobalValuesOutputToLocalValues ("[iitem]"); #>
<# ComputeDifferenceFiniteDerivatives(); #>
<# PrintDebugValuesInfos ("[iitem]"); #>
<# PrintDebugDerivativesInfos ("[iitem]"); #>
<# CopyLocalOutputsDerivativesDiffToGlobalDerivatives ("[iitem]"); #>
    }
  }
  
  void _check_derivatives(const Law::ArrayAccessor& accessor,
                          const Arcane::Integer& begin,
                          const Arcane::Integer& end) const
  {
<# AccessGlobalValues (); #>
<# AccessGlobalDerivatives (); #>
<# AllocateLocalData (); #>
<# AllocateLocalDataFiniteDiff (); #>
<# CreateDerivativesOffsets (); #>
    m_trace_mng->info()<<"<#= Model.name #>"<< " debug evaluation";
    m_trace_mng->info()<<"Check consistency between law derivatives and finite difference ones";
    // Evaluation loop
    for(Arcane::Integer index = begin; index < end; ++index) {
<# CopyGlobalValuesToLocalValues ("[index]"); #>
<# CopyGlobalValuesOutputToLocalValues ("[index]"); #>
<# ComputeDifferenceFiniteDerivatives(); #>
<# PrintDebugValuesInfos ("[index]"); #>
<# PrintDebugDerivativesInfos ("[index]"); #>
<# CopyLocalOutputsDerivativesDiffToGlobalDerivatives ("[index]"); #>
    }
  }
  
  void _check_derivatives(const Law::ScalarAccessor& accessor) const
  {
<# AccessGlobalValues (); #>
<# AccessGlobalDerivatives (); #>
<# AllocateLocalData (); #>
<# AllocateLocalDataFiniteDiff (); #>
<# CreateDerivativesOffsets (); #>
    m_trace_mng->info()<<"<#= Model.name #>"<< " debug evaluation";
    m_trace_mng->info()<<"Check consistency between law derivatives and finite difference ones";
    // Evaluation
    {
<# CopyGlobalValuesToLocalValues ("()", true); #>
<# CopyGlobalValuesOutputToLocalValues ("()", true); #>
<# ComputeDifferenceFiniteDerivatives(); #>
<# PrintDebugValuesInfos ("()"); #>
<# PrintDebugDerivativesInfos (""); #>
<# CopyLocalOutputsDerivativesDiffToGlobalDerivatives (""); #>
    }
  }
<# } #>
private:

<# if(Inputs.Count()>0)
   { #>
  void _print_value(const Arcane::String value_name, const Arcane::Real& value) const
  {
    m_trace_mng->info() << value_name <<" value   = "<< value ;
  }

  void _print_derivatives(const Arcane::String deriv_name, const Arcane::Real& deriv_ref, const Arcane::Real& deriv_test) const
  {
    m_trace_mng->info() << deriv_name <<" ref   = "<< deriv_ref ;
    m_trace_mng->info() << deriv_name <<" test  = "<< deriv_test ;
    m_trace_mng->info() << deriv_name <<" error = "<< (deriv_ref - deriv_test) / (fabs(deriv_ref) + 1.e-20);
  }
<# } #>

private:

  //! Epsilon values to compute derivatives
  EpsilonDerivatives m_epsilon;
  
  //! Manager de trace
  Arcane::ITraceMng* m_trace_mng;

};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
<#  } #>

}

#endif

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
<#+
private bool containsVectorProperty () 
{
  foreach(var p in AllProperties) { 
  	if(p.dim == PropertyDim.vectorial)
  	  return true;
  }
  return false;
}
private void StaticGlobalDependenciesSize () 
{ #>
   
    // Derivatives dependencies sizes
    const Arcane::Integer nb_graph_prop = graph_dependencies.size();
    const Arcane::Integer nb_direct_prop = in().size();
<#+ 
}

private void ComputeDerivativesReorderOffset () 
{ #>
      Arcane::IntegerUniqueArray static_ofs(nb_direct_prop);
      Arcane::Integer graph_composed_ofs = nb_graph_prop;
      auto in_prop = in();
      Arcane::Integer nb_root_prop = 0;
      for(Arcane::Integer static_index = 0; static_index<nb_direct_prop;++static_index)
      {
        auto prop = in_prop[static_index];
        // Move composed derivatives to the end
        if(in_composed_derivative_ofs.find(prop) != in_composed_derivative_ofs.end())
          static_ofs[static_index] = graph_composed_ofs++;
        // Move root properties to the consistent graph index
        else
        {
          static_ofs[static_index]=graph_dependencies[prop];
          nb_root_prop++;
        }
      }
      // Non root graph derivatives equals zero before correction
      const Arcane::Integer nb_inherited_prop = nb_graph_prop - nb_root_prop;
      Arcane::IntegerUniqueArray inherited_deriv_ofs(nb_inherited_prop);
      Arcane::Integer inherited_index = 0;
      for(Arcane::Integer graph_index = 0; graph_index<nb_graph_prop;++graph_index)
      {
        if(!in_prop.contains(graph_dependencies[graph_index]))
          inherited_deriv_ofs[inherited_index++]=graph_index;
      }
<#+ 
}
private void ReorderDerivativesAndNullify (string op) 
{ #>
<#+ 
  foreach(var o in Outputs) { 
    switch(o.dim) {
    case PropertyDim.scalar : #>
        Arcane::<#= o.type.Name() #>UniqueArray var_deriv_<#= o.name #>_ini(var_deriv_<#= o.name #><#= op #>.constView());
<#+ 
    break;
    case PropertyDim.multiscalar : #>
        Arcane::Integer size_<#= o.name #> = m_signature.<#= o.name #>.size();
        Arcane::UniqueArray<Arcane::<#= o.type.Name() #>ConstArrayView> var_deriv_<#= o.name #>_ini(size_<#= o.name #>);
        for(auto j = 0; j < size_<#= o.name #>; ++j) {
          var_deriv_<#= o.name #>_ini[j] = var_deriv_<#= o.name #>[j]<#= op #>;
        }
<#+ 
    break;
    } 
  } #>
        for(Arcane::Integer static_index=0;static_index<nb_direct_prop;++static_index)
        {
<#+ 
  foreach(var o in Outputs) { 
    switch(o.dim) {
    case PropertyDim.scalar : #>
          var_deriv_<#= o.name #><#= op #>[static_ofs[static_index]] = var_deriv_<#= o.name #>_ini[static_index];
<#+ 
    break;
    case PropertyDim.multiscalar : #>
         for(auto j = 0; j < size_<#= o.name #>; ++j) {
              var_deriv_<#= o.name #>[j]<#= op #>[static_ofs[static_index]] = var_deriv_<#= o.name #>_ini[j][static_index];
         }
<#+    
    break;
    } 
  } #>
        }
        for(Arcane::Integer inherited_index=0;inherited_index<nb_inherited_prop;++inherited_index)
        {
<#+ 
  foreach(var o in Outputs) { 
    switch(o.dim) {
    case PropertyDim.scalar : #>
          var_deriv_<#= o.name #><#= op #>[inherited_deriv_ofs[inherited_index]]=0;
<#+ 
    break;
    case PropertyDim.multiscalar : #>
         for(auto j = 0; j < size_<#= o.name #>; ++j) {
              var_deriv_<#= o.name #>[j]<#= op #>[inherited_deriv_ofs[inherited_index]] = 0;
         }
<#+ 
    break;
    } 
  } #>
       }
<#+
}
private void ComputeDerivativesCorrectionOffset () 
{#>
      direct_composed_index++;
      // Derivatives correction through in derivatives properties
      Law::PropertyVector composed_prop_deriv = iter_composed.second;
      Arcane::Integer nb_composed_prop_deriv = composed_prop_deriv.size();
      Arcane::IntegerUniqueArray composed_prop_deriv_ofs(nb_composed_prop_deriv);
      for(Arcane::Integer composed_deriv_index=0;composed_deriv_index<nb_composed_prop_deriv;++composed_deriv_index){
        auto current_in_derived_prop = composed_prop_deriv[composed_deriv_index];
        composed_prop_deriv_ofs[composed_deriv_index] = graph_dependencies[current_in_derived_prop];
      }
      // Only real scalar avalaible in this version (external check)
      Law::Property composed_prop = iter_composed.first;
      Law::ScalarRealProperty& scalar_composed_prop = static_cast<Law::ScalarRealProperty&>(composed_prop);
      // In proproperties has derivatives (external check)
      auto deriv_composed = accessor.derivatives(scalar_composed_prop);
<#+
}
private void parallelEnumerate(string groupName, string lambdaName) 
{
    if(MultiThread == MultiThreadMode.ArcaneTBB) {
#>
      int nb_thread = Arcane::TaskFactory::nbAllowedThread();
      Arcane::ParallelLoopOptions para_options;
      para_options.setMaxThread(nb_thread);
      int grain_size = group.size()/nb_thread + 1;
      para_options.setGrainSize(grain_size);
      Arcane::Parallel::Foreach(<#= groupName #>, para_options, <#= lambdaName #>);
<#+
    }
    else if(MultiThread == MultiThreadMode.Kokkos) {
#>
      Kokkos::parallel_for("<#= groupName #>", group.size(), <#= lambdaName #>);
<#+
    }
}
private void ApplyDerivativesCorrection(string op) 
{
  foreach(var o in Outputs) { 
    switch(o.dim) {
    case PropertyDim.scalar : #>
        auto direct_derivative_<#= o.name #> = var_deriv_<#= o.name #><#= op #>[direct_composed_index];
<#+ 
    break;
    case PropertyDim.multiscalar : #>
        Arcane::Integer size_<#= o.name #> = m_signature.<#= o.name #>.size();
        Arcane::<#= o.type.Name() #>UniqueArray direct_derivative_<#= o.name #>(size_<#= o.name #>);
        for(auto j = 0; j < size_<#= o.name #>; ++j) {
          direct_derivative_<#= o.name #>[j] = var_deriv_<#= o.name #>[j]<#= op #>[direct_composed_index];
        }
<#+ 
    break;
    } 
  } #>
        for(auto derived_index = 0; derived_index < nb_composed_prop_deriv; ++derived_index)
        {
<#+ 
  foreach(var o in Outputs) { 
    switch(o.dim) {
    case PropertyDim.scalar : #>
          var_deriv_<#= o.name #><#= op #>[composed_prop_deriv_ofs[derived_index]] += direct_derivative_<#= o.name #>*deriv_composed<#= op #>[derived_index];
<#+ 
    break;
    case PropertyDim.multiscalar : #>
        for(auto j = 0; j < size_<#= o.name #>; ++j) {
          var_deriv_<#= o.name #>[j]<#= op #>[composed_prop_deriv_ofs[derived_index]] += direct_derivative_<#= o.name #>[j]*deriv_composed<#= op #>[derived_index];
        }
<#+ 
    break;
    } 
  } #>
        }
<#+
}
private void AccessGlobalValues () 
{ #>
    // Access to global values container
<#+
  foreach(var p in AllProperties) { #>
    auto var_<#= p.name #> = accessor.values(m_signature.<#= p.name #>);
<#+
  }
}

private void AccessGlobalDerivatives () 
{ #>
    // Access to global derivatives container
<#+
  foreach(var o in Outputs) { #>
    auto var_deriv_<#= o.name #> = accessor.derivatives(m_signature.<#= o.name #>);
<#+
  }
}

private void ResizeGlobalDerivatives (bool need_resize_array = false) 
{ #>
    // Resize global outputs
<#+
  foreach(var o in Outputs) { 
    switch(o.dim) {
    case PropertyDim.scalar : #>
    var_deriv_<#= o.name #>.resize(size);
<#+ 
    break;
    case PropertyDim.multiscalar : #>
    for(auto i = 0; i < m_signature.<#= o.name #>.size(); ++i) {
      var_deriv_<#= o.name #>[i].resize(size);
    }
<#+ 
    break;
    case PropertyDim.vectorial : 
    if(need_resize_array) { #>
    var_deriv_<#= o.name #>.resize(var_deriv_<#= o.name #>.dim1Size(), m_signature.<#= o.name #>.size(),size);
<#+ 
    } else { #>
    var_deriv_<#= o.name #>.resize(m_signature.<#= o.name #>.size(),size);
<#+ 
    }
    break;
    } 
  }
}

private void CreateDerivativesOffsets () 
{ #>
    // Create derivatives offsets
<#+
  Property prev = null;
  foreach(var p in Inputs) {
    if(prev == null) { #>
    auto ofs_<#= p.name #> = 0;
<#+ 
    } else if (prev.dim != PropertyDim.scalar) { #>
    auto ofs_<#= p.name #> = ofs_<#= prev.name #> + m_signature.<#= prev.name #>.size();
<#+ 
    } else { #>
    auto ofs_<#= p.name #> = ofs_<#= prev.name #> + 1;
<#+
    }
    prev = p;
  }
}

private void AllocateLocalData ()
{ #>
    // Allocate local inputs
<#+
  foreach(var i in Inputs) { 
    switch(i.dim) {
    case PropertyDim.scalar : #>
    Arcane::<#= i.type.Name() #> <#= i.name #>;
<#+ 
    break;
    case PropertyDim.multiscalar : #>
    Arcane::<#= i.type.Name() #>UniqueArray <#= i.name #>(m_signature.<#= i.name #>.size());
<#+ 
    break;
    case PropertyDim.vectorial : #>
    Arcane::<#= i.type.Name() #>ConstArrayView <#= i.name #>;
<#+ 
    break;
    } 
  } #>
    // Allocate local outputs
<#+
  foreach(var o in Outputs) { 
    switch(o.dim) {
    case PropertyDim.scalar : #>
    Arcane::<#= o.type.Name() #> <#= o.name #>;
<#+ 
    foreach(var i in Inputs) {
      switch(i.dim) {
      case PropertyDim.scalar : #>
    Arcane::<#= o.type.Name() #> <#= o.name #>_wrt_<#= i.name #>;
<#+
      break;
      case PropertyDim.multiscalar : #>
    Arcane::<#= o.type.Name() #>UniqueArray <#= o.name #>_wrt_<#= i.name #>(m_signature.<#= i.name #>.size());
<#+
      break;
      case PropertyDim.vectorial : #>
    Arcane::<#= o.type.Name() #>UniqueArray <#= o.name #>_wrt_<#= i.name #>(m_signature.<#= i.name #>.size());
<#+
      break;
      }
    }
    break;
    case PropertyDim.multiscalar : #>
    Arcane::<#= o.type.Name() #>UniqueArray <#= o.name #>(m_signature.<#= o.name #>.size());
<#+ 
    foreach(var i in Inputs) {
      switch(i.dim) {
      case PropertyDim.scalar : #>
    Arcane::<#= o.type.Name() #>UniqueArray <#= o.name #>_wrt_<#= i.name #>(m_signature.<#= o.name #>.size());
<#+
      break;
      case PropertyDim.multiscalar : #>
    Arcane::<#= o.type.Name() #>UniqueArray2 <#= o.name #>_wrt_<#= i.name #>(m_signature.<#= o.name #>.size(),m_signature.<#= i.name #>.size());
<#+
      break;
      case PropertyDim.vectorial : #>
    Arcane::<#= o.type.Name() #>UniqueArray2 <#= o.name #>_wrt_<#= i.name #>(m_signature.<#= o.name #>.size(),m_signature.<#= i.name #>.size());
<#+
      break;
      }
    }
    break;
    case PropertyDim.vectorial : #>
    Arcane::<#= o.type.Name() #>UniqueArray <#= o.name #>(m_signature.<#= o.name #>.size());
<#+ 
    foreach(var i in Inputs) {
      switch(i.dim) {
      case PropertyDim.scalar : #>
    Arcane::<#= o.type.Name() #>UniqueArray <#= o.name #>_wrt_<#= i.name #>(m_signature.<#= o.name #>.size());
<#+
      break;
      case PropertyDim.multiscalar : #>
    Arcane::<#= o.type.Name() #>UniqueArray2 <#= o.name #>_wrt_<#= i.name #>(m_signature.<#= o.name #>.size(),m_signature.<#= i.name #>.size());
<#+
      break;
      case PropertyDim.vectorial : #>
    Arcane::<#= o.type.Name() #>UniqueArray2 <#= o.name #>_wrt_<#= i.name #>(m_signature.<#= o.name #>.size(),m_signature.<#= i.name #>.size());
<#+
      break;
      }
    }
    break;
    }
  } #>
    // Allocate local parameters
<#+
  foreach(var p in Parameters) { 
    switch(p.dim) {
    case PropertyDim.scalar : #>
    Arcane::<#= p.type.Name() #> <#= p.name #>;
<#+ 
    break;
    case PropertyDim.multiscalar : #>
    Arcane::<#= p.type.Name() #>UniqueArray <#= p.name #>(m_signature.<#= p.name #>.size());
<#+ 
    break;
    case PropertyDim.vectorial : #>
    Arcane::<#= p.type.Name() #>ConstArrayView <#= p.name #>;
<#+ 
    break;
    }
  }
}

private void CopyGlobalValuesToLocalValues (string op, bool vectorial_no_op = false)
{ #>
      // Copy global inputs values to local values
<#+
  foreach(var i in Inputs) { 
    switch(i.dim) {
    case PropertyDim.scalar : #>
      <#= i.name #> = var_<#= i.name #><#= op #>;
<#+ 
    break;
    case PropertyDim.multiscalar : #>
      for(auto i = 0; i < m_signature.<#= i.name #>.size(); ++i) {
        <#= i.name #>[i] = var_<#= i.name #>[i]<#= op #>;
      }
<#+ 
    break;
    case PropertyDim.vectorial : 
    if(vectorial_no_op) { #>
      <#= i.name #> = var_<#= i.name #>;
<#+ 
    } else { #>
      <#= i.name #> = var_<#= i.name #><#= op #>;
<#+ 
    }
    break;
    }
  } #>
      // Copy global parameters values to local values
<#+
  foreach(var p in Parameters) { 
    switch(p.dim) {
    case PropertyDim.scalar : #>
      <#= p.name #> = var_<#= p.name #><#= op #>;
<#+ 
    break;
    case PropertyDim.multiscalar : #>
      for(auto i = 0; i < m_signature.<#= p.name #>.size(); ++i) {
        <#= p.name #>[i] = var_<#= p.name #>[i]<#= op #>;
      }
<#+ 
    break;
    case PropertyDim.vectorial : 
    if(vectorial_no_op) { #>
      <#= p.name #> = var_<#= p.name #>;
<#+ 
    } else { #>
      <#= p.name #> = var_<#= p.name #><#= op #>;
<#+
    }
    break;
    }
  }
} 

private void CopyLocalOutputsValuesToGlobalValues (string op)
{ #>
      // Copy local outputs values to global values
<#+
  foreach(var o in Outputs) { 
    switch(o.dim) {
    case PropertyDim.scalar : #>
      var_<#= o.name #><#= op #> = <#= o.name #>;
<#+ 
    break;
    case PropertyDim.multiscalar : #>
      for(auto i = 0; i < m_signature.<#= o.name #>.size(); ++i) {
        var_<#= o.name #>[i]<#= op #> = <#= o.name #>[i];
      }
<#+ 
    break;
    case PropertyDim.vectorial : #>
      for(auto i = 0; i < m_signature.<#= o.name #>.size(); ++i) {
        var_<#= o.name #><#= op #>[i] = <#= o.name #>[i];
      }
<#+ 
    break;
    }
  }
} 
private void CopyLocalOutputsDerivativesToGlobalDerivatives (string op)
{ #>
      // Copy local outputs derivatives to global derivatives
<#+
  foreach(var o in Outputs) { 
    switch(o.dim) {
    case PropertyDim.scalar : 
    foreach(var i in Inputs) {
      switch(i.dim) {
      case PropertyDim.scalar : #>
      var_deriv_<#= o.name #><#= op #>[ofs_<#= i.name #>] = <#= o.name #>_wrt_<#= i.name #>;
<#+
      break;
      case PropertyDim.multiscalar : #>
      for(auto i = 0; i < m_signature.<#= i.name #>.size(); ++i) {
        var_deriv_<#= o.name #><#= op #>[ofs_<#= i.name #>+i] = <#= o.name #>_wrt_<#= i.name #>[i];
      }
<#+
      break;
      case PropertyDim.vectorial : #>
      for(auto i = 0; i < m_signature.<#= i.name #>.size(); ++i) {
        var_deriv_<#= o.name #><#= op #>[ofs_<#= i.name #>+i] = <#= o.name #>_wrt_<#= i.name #>[i];
      }
<#+
      break;
      }
    }
    break;
    case PropertyDim.multiscalar : #>
      for(auto i = 0; i < m_signature.<#= o.name #>.size(); ++i) {
<#+
    foreach(var i in Inputs) {
      switch(i.dim) {
      case PropertyDim.scalar : #>
        var_deriv_<#= o.name #>[i]<#= op #>[ofs_<#= i.name #>] = <#= o.name #>_wrt_<#= i.name #>[i];
<#+
      break;
      case PropertyDim.multiscalar : #>
        for(auto j = 0; j < m_signature.<#= i.name #>.size(); ++j) {
          var_deriv_<#= o.name #>[i]<#= op #>[ofs_<#= i.name #>+j] = <#= o.name #>_wrt_<#= i.name #>[i][j];
        }
<#+
      break;
      case PropertyDim.vectorial : #>
        for(auto j = 0; j < m_signature.<#= i.name #>.size(); ++j) {
          var_deriv_<#= o.name #>[i]<#= op #>[ofs_<#= i.name #>+j] = <#= o.name #>_wrt_<#= i.name #>[i][j];
        }
<#+
      break;
      } 
    } #>
      }
<#+
    break;
    case PropertyDim.vectorial : #>
      for(auto i = 0; i < m_signature.<#= o.name #>.size(); ++i) {
<#+
    foreach(var i in Inputs) {
      switch(i.dim) {
      case PropertyDim.scalar : #>
        var_deriv_<#= o.name #><#= op #>[i][ofs_<#= i.name #>] = <#= o.name #>_wrt_<#= i.name #>[i];
<#+
      break;
      case PropertyDim.multiscalar : #>
        for(auto j = 0; j < m_signature.<#= i.name #>.size(); ++j) {
          var_deriv_<#= o.name #><#= op #>[i][ofs_<#= i.name #>+j] = <#= o.name #>_wrt_<#= i.name #>[i][j];
        }
<#+
      break;
      case PropertyDim.vectorial : #>
        for(auto j = 0; j < m_signature.<#= i.name #>.size(); ++j) {
          var_deriv_<#= o.name #><#= op #>[i][ofs_<#= i.name #>+j] = <#= o.name #>_wrt_<#= i.name #>[i][j];
        }
<#+
      break;
      }
    } #>
      }
<#+
    break;
    }
  }
} 
private void AllocateLocalDataFiniteDiff ()
{ #>
    // Allocate local outputs values to compute difference finite derivatives
<#+
  foreach(var o in Outputs) { 
    switch(o.dim) {
    case PropertyDim.scalar : #>
    Arcane::<#= o.type.Name() #> <#= o.name #>_ref;
<#+ 
    foreach(var i in Inputs) {
      switch(i.dim) {
      case PropertyDim.scalar : #>
    Arcane::<#= o.type.Name() #> <#= o.name #>_wrt_<#= i.name #>_diff;
<#+
      break;
      case PropertyDim.multiscalar : #>
    Arcane::<#= o.type.Name() #>UniqueArray <#= o.name #>_wrt_<#= i.name #>_diff(m_signature.<#= i.name #>.size());
<#+
      break;
      }
    }
    break;
    case PropertyDim.multiscalar : #>
    Arcane::<#= o.type.Name() #>UniqueArray <#= o.name #>_ref(m_signature.<#= o.name #>.size());
<#+
    foreach(var i in Inputs) {
      switch(i.dim) {
      case PropertyDim.scalar : #>
    Arcane::<#= o.type.Name() #>UniqueArray <#= o.name #>_wrt_<#= i.name #>_diff(m_signature.<#= o.name #>.size());
<#+
      break;
      case PropertyDim.multiscalar : #>
    Arcane::<#= o.type.Name() #>UniqueArray2 <#= o.name #>_wrt_<#= i.name #>_diff(m_signature.<#= o.name #>.size(),m_signature.<#= i.name #>.size());
<#+
      break;
      }
    }
    break;
    }
  }
}
private void CopyGlobalValuesOutputToLocalValues (string op, bool vectorial_no_op = false)
{ #>
      // Copy global inputs values to local values
<#+
  foreach(var o in Outputs) { 
    switch(o.dim) {
    case PropertyDim.scalar : #>
      <#= o.name #>_ref = var_<#= o.name #><#= op #>;
<#+ 
    break;
    case PropertyDim.multiscalar : #>
      for(auto i = 0; i < m_signature.<#= o.name #>.size(); ++i) {
        <#= o.name #>_ref[i] = var_<#= o.name #>[i]<#= op #>;
      }
<#+ 
    break;
    }
  }
}
private void ComputeDifferenceFiniteDerivatives ()
{
  foreach(var i in Inputs) { #>
      // compute difference finite derivatives through <#= i.name #>
<#+ 
    switch(i.dim) {
    case PropertyDim.scalar : #>
      {
        <#= i.name #> += m_epsilon.<#= i.name #>;
        // Invoke user kernel
        m_invoker(
          <#= InvokerCallSignature #>
        );
        <#= i.name #> -= m_epsilon.<#= i.name #>;
<#+ 
    foreach(var o in Outputs) {
      switch(o.dim) {
      case PropertyDim.scalar : #>
        <#= o.name #>_wrt_<#= i.name #>_diff = (<#= o.name #> - <#= o.name #>_ref) / m_epsilon.<#= i.name #>;
<#+
      break;
      case PropertyDim.multiscalar : #>
        for(auto i = 0; i < m_signature.<#= o.name #>.size(); ++i)
          <#= o.name #>_wrt_<#= i.name #>_diff[i] = (<#= o.name #>[i] - <#= o.name #>_ref[i]) / m_epsilon.<#= i.name #>;
<#+
      break;
      }
    } #>
      }
<#+
    break;
    case PropertyDim.multiscalar : #>
      for(int i = 0; i < m_signature.<#= i.name #>.size(); ++i) {
        <#= i.name #>[i] += m_epsilon.<#= i.name #>;
        // Invoke user kernel
        m_invoker(
          <#= InvokerCallSignature #>
        );
        <#= i.name #>[i] -= m_epsilon.<#= i.name #>;
<#+
    foreach(var o in Outputs) {
      switch(o.dim) {
      case PropertyDim.scalar : #>
        <#= o.name #>_wrt_<#= i.name #>_diff[i] = (<#= o.name #> - <#= o.name #>_ref) / m_epsilon.<#= i.name #>;
<#+
      break;
      case PropertyDim.multiscalar : #>
        for(int j = 0; j < m_signature.<#= o.name #>.size(); ++j)
          <#= o.name #>_wrt_<#= i.name #>_diff[j][i] = (<#= o.name #>[j] - <#= o.name #>_ref[j]) / m_epsilon.<#= i.name #>;
<#+
      break;
      }
    } #>
      }
<#+           
    break;
    } 
  }
}
private void CopyLocalOutputsDerivativesDiffToGlobalDerivatives (string op)
{ #>
      // Overwrite global derivatives by difference finite ones
      {
<#+
  foreach(var o in Outputs) { 
    switch(o.dim) {
    case PropertyDim.scalar : 
    foreach(var i in Inputs) {
      switch(i.dim) {
      case PropertyDim.scalar : #>
        var_deriv_<#= o.name #><#= op #>[ofs_<#= i.name #>] = <#= o.name #>_wrt_<#= i.name #>_diff;
<#+
      break;
      case PropertyDim.multiscalar : #>
        for(auto i = 0; i < m_signature.<#= i.name #>.size(); ++i)
          var_deriv_<#= o.name #><#= op #>[ofs_<#= i.name #>+i] = <#= o.name #>_wrt_<#= i.name #>_diff[i];
<#+
      break;
      }
    }
    break;
    case PropertyDim.multiscalar : #>
        for(auto i = 0; i < m_signature.<#= o.name #>.size(); ++i) {
<#+
    foreach(var i in Inputs) {
      switch(i.dim) {
      case PropertyDim.scalar : #>
          var_deriv_<#= o.name #>[i]<#= op #>[ofs_<#= i.name #>] = <#= o.name #>_wrt_<#= i.name #>_diff[i];
<#+
      break;
      case PropertyDim.multiscalar : #>
          for(auto j = 0; j < m_signature.<#= i.name #>.size(); ++j)
            var_deriv_<#= o.name #>[i]<#= op #>[ofs_<#= i.name #>+j] = <#= o.name #>_wrt_<#= i.name #>_diff[i][j];
<#+
      break;
      } 
    } #>
        }
<#+
    break;
    }
  } #>
      }
<#+
}
private void PrintDebugValuesInfos (string op)
{ #>
      // Print debug values
      {
<#+
  foreach(var o in InOutputs) { 
    switch(o.dim) {
    case PropertyDim.scalar : #>
        _print_value("<#= o.name #>", var_<#= o.name #><#= op #>);
<#+
    break;
    case PropertyDim.multiscalar : #>
        for(auto i = 0; i < m_signature.<#= o.name #>.size(); ++i)
          _print_value(Arcane::String::format("<#= o.name #>[{0}]",i), var_<#= o.name #>[i]<#= op #>);
<#+
    break;
    }
  } #>
      }
<#+    
}
private void PrintDebugDerivativesInfos (string op)
{ #>
      // Print derivatives debug informations
      {
<#+
  foreach(var o in Outputs) { 
    switch(o.dim) {
    case PropertyDim.scalar : 
    foreach(var i in Inputs) {
      switch(i.dim) {
      case PropertyDim.scalar : #>
        _print_derivatives("d<#= o.name #>_d<#= i.name #>", var_deriv_<#= o.name #><#= op #>[ofs_<#= i.name #>], <#= o.name #>_wrt_<#= i.name #>_diff);
<#+
      break;
      case PropertyDim.multiscalar : #>
        for(auto i = 0; i < m_signature.<#= i.name #>.size(); ++i)
          _print_derivatives(Arcane::String::format("d<#= o.name #>_d<#= i.name #>[{0}]",i), var_deriv_<#= o.name #><#= op #>[ofs_<#= i.name #>+i], <#= o.name #>_wrt_<#= i.name #>_diff[i]);
<#+
      break;
      }
    }
    break;
    case PropertyDim.multiscalar : #>
        for(auto i = 0; i < m_signature.<#= o.name #>.size(); ++i) {
<#+
    foreach(var i in Inputs) {
      switch(i.dim) {
      case PropertyDim.scalar : #>
          _print_derivatives(Arcane::String::format("d<#= o.name #>[{0}]_d<#= i.name #>",i), var_deriv_<#= o.name #>[i]<#= op #>[ofs_<#= i.name #>], <#= o.name #>_wrt_<#= i.name #>_diff[i]);
<#+
      break;
      case PropertyDim.multiscalar : #>
          for(auto j = 0; j < m_signature.<#= i.name #>.size(); ++j)
            _print_derivatives(Arcane::String::format("d<#= o.name #>[{0}]_d<#= i.name #>[{1}]",i,j), var_deriv_<#= o.name #>[i]<#= op #>[ofs_<#= i.name #>+j], <#= o.name #>_wrt_<#= i.name #>_diff[i][j]);
<#+
      break;
      } 
    } #>
        }
<#+
    break;
    }
  } #>
      }
<#+    
}
#>
