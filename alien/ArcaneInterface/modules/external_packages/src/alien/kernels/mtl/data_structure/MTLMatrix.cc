#include "MTLMatrix.h"
/* Author : mesriy at Tue Jul 24 15:56:45 2012
 * Generated by createNew
 */

#include <alien/kernels/mtl/data_structure/MTLVector.h>
#include <alien/kernels/mtl/data_structure/MTLInternal.h>
#include <alien/kernels/mtl/MTLBackEnd.h>

#include <alien/core/impl/MultiMatrixImpl.h>

/*---------------------------------------------------------------------------*/

namespace Alien {

/*---------------------------------------------------------------------------*/

MTLMatrix::MTLMatrix(const MultiMatrixImpl* multi_impl)
: IMatrixImpl(multi_impl, AlgebraTraits<BackEnd::tag::mtl>::name())
, m_internal(NULL)
{
  const auto& row_space = multi_impl->rowSpace();
  const auto& col_space = multi_impl->colSpace();
  if (row_space.size() != col_space.size())
    throw Arccore::FatalErrorException("MTL matrix must be square");
}

/*---------------------------------------------------------------------------*/

MTLMatrix::~MTLMatrix()
{
  delete m_internal;
}

/*---------------------------------------------------------------------------*/

bool
MTLMatrix::initMatrix(
    std::vector<std::size_t> const& offsets, const int rank, const int nproc)
{
  delete m_internal;
  std::size_t global_size = offsets[nproc];
#ifdef USE_PMTL4
  mtl::par::block_distribution row_dist(offsets);
  m_internal = new MatrixInternal(global_size, global_size, row_dist);
#else
  m_internal = new MatrixInternal(global_size, global_size);
#endif
  return true;
}

/*---------------------------------------------------------------------------*/

bool
MTLMatrix::addMatrixValues(const int nrow, const int* rows, const int* row_offset,
    const int* cols, const double* values)
{
  MTL4Internal::Features::checkParallel(distribution());
#ifdef MTL_4_0_9555
  mtl::mat::inserter<MTL4Internal::MatrixInternal::MTLMatrixType,
      mtl::update_plus<MTL4Internal::MatrixInternal::MTLMatrixType::value_type>>
      ins(m_internal->m_internal);
#else
  mtl::matrix::inserter<MTL4Internal::MatrixInternal::MTLMatrixType,
      mtl::update_plus<MTL4Internal::MatrixInternal::MTLMatrixType::value_type>>
      ins(m_internal->m_internal);
#endif
  int off = 0;
  for (int i = 0; i < nrow; i++)
    for (int j = 0; j < row_offset[i + 1] - row_offset[i]; j++) {
      ins[rows[i]][cols[off]] << values[off];
      off++;
    }
  return true;
}

/*---------------------------------------------------------------------------*/

bool
MTLMatrix::setMatrixValues(const int max_row_size, const int nrow, const int* rows,
    const int* row_offset, const int* cols, const double* values)
{
  MTL4Internal::Features::checkParallel(distribution());
#ifdef MTL_4_0_9555
  mtl::mat::inserter<MTL4Internal::MatrixInternal::MTLMatrixType> ins(
      m_internal->m_internal, max_row_size);
#else
  mtl::matrix::inserter<MTL4Internal::MatrixInternal::MTLMatrixType> ins(
      m_internal->m_internal, max_row_size);
#endif
  int off = 0;
  for (int i = 0; i < nrow; i++)
    for (int j = 0; j < row_offset[i + 1] - row_offset[i]; j++) {
      ins[rows[i]][cols[off]] << values[off];
      off++;
    }
  return true;
}

/*---------------------------------------------------------------------------*/

bool
MTLMatrix::setMatrixBlockValues(const int offset, const int max_row_size,
    const int equations_num, const int unknowns_num, const int nrow,
    const int* row_offset, const int* cols, const double* values)
{
  MTL4Internal::Features::checkParallel(distribution());
#ifdef MTL_4_0_9555
  mtl::mat::inserter<MTL4Internal::MatrixInternal::MTLMatrixType> ins(
      m_internal->m_internal, max_row_size);
#else
  mtl::matrix::inserter<MTL4Internal::MatrixInternal::MTLMatrixType> ins(
      m_internal->m_internal, max_row_size);
#endif
  int bs = equations_num * unknowns_num;
  int un = unknowns_num;
  int col_count = 0;
  int mat_count = 0;
  for (int irow = 0; irow < nrow; ++irow) {
    int row = offset + irow;
    int ncols = row_offset[irow + 1] - row_offset[irow];
    for (int k = 0; k < ncols; ++k) {
      for (int i = 0; i < equations_num; ++i) {
        int ir = row * equations_num + i;
        for (int j = 0; j < unknowns_num; ++j) {
          int jc = cols[col_count + k] * unknowns_num + j;
          ins[ir][jc] << values[mat_count + ijk(i, j, k, bs, un)];
        }
      }
    }
    col_count += ncols;
    mat_count += ncols * bs;
  }
  return true;
}

/*---------------------------------------------------------------------------*/

} // namespace Alien

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
