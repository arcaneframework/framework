// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2024 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------

#include "PETScMatrix.h"
#include "PETScVector.h"
/* Author : havep at Wed Jul 18 14:46:45 2012
 * Generated by createNew
 */

#include "petscmat.h"
#include <alien/kernels/petsc/data_structure/PETScVector.h>
#include <alien/kernels/petsc/PETScBackEnd.h>
#include <alien/kernels/petsc/data_structure/PETScInternal.h>

#include <alien/core/impl/MultiMatrixImpl.h>

/*---------------------------------------------------------------------------*/

namespace Alien {

/*---------------------------------------------------------------------------*/

PETScMatrix::PETScMatrix(const MultiMatrixImpl* multi_impl)
: IMatrixImpl(multi_impl, AlgebraTraits<BackEnd::tag::petsc>::name())
//, m_internal(nullptr)
{
  const auto& row_space = multi_impl->rowSpace();
  const auto& col_space = multi_impl->colSpace();
  if (row_space.size() != col_space.size())
    throw Arccore::FatalErrorException("MTL matrix must be square");
}

/*---------------------------------------------------------------------------*/

PETScMatrix::~PETScMatrix()
{
  //delete m_internal;
}

PETScMatrix::MatrixInternal* PETScMatrix::internal() {
  return m_internal.get();
}

const PETScMatrix::MatrixInternal*
PETScMatrix::internal() const {
  return m_internal.get();
}

/*---------------------------------------------------------------------------*/

bool
PETScMatrix::initMatrix(const int local_size,
                        const int local_offset,
                        const int global_size,
                        const int block_size,
                        Arccore::ConstArrayView<Arccore::Integer> diag_lineSizes,
                        Arccore::ConstArrayView<Arccore::Integer> offdiag_lineSizes,
                        const bool parallel)
{
  int ierr = 0; // code d'erreur de retour

  m_internal.reset(new MatrixInternal{local_offset,local_size,block_size,parallel});

  Arccore::Integer max_diag_size = 0, max_offdiag_size = 0;

// -- Matrix --
#ifdef PETSC_HAVE_MATVALID
  PetscTruth valid_flag;
  ierr += MatValid(m_internal->m_internal, &valid_flag);
  if (valid_flag == PETSC_TRUE)
    return (ierr == 0);
#endif /* PETSC_HAVE_MATVALID */

  ierr += MatCreate(PETSC_COMM_WORLD, &m_internal->m_internal);
  ierr += MatSetSizes(
      m_internal->m_internal, local_size, local_size, global_size, global_size);
#ifdef PETSC_HAVE_MATSETBLOCKSIZE
  if(block_size>1)
    ierr += MatSetBlockSize(m_internal->m_internal, block_size) ;
#endif
  ierr += MatSetType(m_internal->m_internal, m_internal->m_type);

  if (parallel) { // Use parallel structures
    ierr += MatMPIAIJSetPreallocation(m_internal->m_internal, max_diag_size,
        diag_lineSizes.unguardedBasePointer(), max_offdiag_size,
        offdiag_lineSizes.unguardedBasePointer());
  } else { // Use sequential structures
    ierr += MatSeqAIJSetPreallocation(
        m_internal->m_internal, max_diag_size, diag_lineSizes.unguardedBasePointer());
  }

  // Offsets are implicit with PETSc, we can to check that
  // they are compatible with the expected behaviour
  PetscInt low;
  ierr += MatGetOwnershipRange(m_internal->m_internal, &low, nullptr);
  if (low != local_offset)
    return false;

  return (ierr == 0);
}

/*---------------------------------------------------------------------------*/

bool
PETScMatrix::addMatrixValues(
    const int row, const int ncols, const int* cols, const Arccore::Real* values)
{
  assert(m_internal.get()) ;
  int ierr =
      MatSetValues(m_internal->m_internal, 1, &row, ncols, cols, values, ADD_VALUES);
  return (ierr == 0);
}

/*---------------------------------------------------------------------------*/

bool
PETScMatrix::setMatrixValues(
    const int row, const int ncols, const int* cols, const Arccore::Real* values)
{
  assert(m_internal.get()) ;
  int ierr =
      MatSetValues(m_internal->m_internal, 1, &row, ncols, cols, values, INSERT_VALUES);
  return (ierr == 0);
}


#ifdef PETSC_HAVE_MATSETBLOCKSIZE
bool
PETScMatrix::addMatrixBlockValues(
    const int row, const int ncols, const int* cols, const Arccore::Real* values)
{
  assert(m_internal.get()) ;
  int ierr =
      MatSetValuesBlocked(m_internal->m_internal, 1, &row, ncols, cols, values, ADD_VALUES);
  return (ierr == 0);
}

bool
PETScMatrix::setMatrixBlockValues(
    const int row, const int ncols, const int* cols, const Arccore::Real* values)
{
  assert(m_internal.get()) ;
  int ierr =
      MatSetValuesBlocked(m_internal->m_internal, 1, &row, ncols, cols, values, INSERT_VALUES);
  return (ierr == 0);
}
#endif
/*---------------------------------------------------------------------------*/
void PETScMatrix::setMatrixCoordinate(Vector const& x, Vector const& y, Vector const& z)
{
  assert(m_internal.get()) ;
  m_internal->m_coordinates_dim = 3;
  PetscScalar *c;
  VecCreate(MPI_COMM_WORLD, &m_internal->m_coordinates);
#ifdef PETSC_HAVE_VECSETBLOCKSIZE
  VecSetBlockSize(m_internal->m_coordinates, m_internal->m_coordinates_dim);
#endif
  VecSetSizes(m_internal->m_coordinates, m_internal->m_local_size, PETSC_DECIDE);
  VecSetUp(m_internal->m_coordinates);
  VecGetArray(m_internal->m_coordinates, &c);

  Alien::LocalVectorReader x_view(x);
  Alien::LocalVectorReader y_view(y);
  Alien::LocalVectorReader z_view(z);

  {
    Integer offset = 0 ;
    for(int i=0;i<m_internal->m_local_size/m_internal->m_block_size;++i)
    {
      c[offset    ] = x_view[i] ;
      c[offset + 1] = y_view[i] ;
      c[offset + 2] = z_view[i] ;
      offset += m_internal->m_coordinates_dim ;
    }
  }
  VecRestoreArray(m_internal->m_coordinates, &c);
  m_internal->m_has_coordinates = true ;
}

void PETScMatrix::setMatrixCoordinate(Vector const& x, Vector const& y)
{
  assert(m_internal.get()) ;
  m_internal->m_coordinates_dim = 2 ;
  PetscScalar *c;
  VecCreate(MPI_COMM_WORLD, &m_internal->m_coordinates);
#ifdef PETSC_HAVE_VECSETBLOCKSIZE
  VecSetBlockSize(m_internal->m_coordinates, m_internal->m_coordinates_dim);
#endif
  VecSetSizes(m_internal->m_coordinates, m_internal->m_local_size, PETSC_DECIDE);
  VecSetUp(m_internal->m_coordinates);
  VecGetArray(m_internal->m_coordinates, &c);

  Alien::LocalVectorReader x_view(x);
  Alien::LocalVectorReader y_view(y);

  {
    Integer offset = 0 ;
    for(int i=0;i<m_internal->m_local_size/m_internal->m_block_size;++i)
    {
      c[offset    ] = x_view[i] ;
      c[offset + 1] = y_view[i] ;
      offset += m_internal->m_coordinates_dim ;
    }
  }
  VecRestoreArray(m_internal->m_coordinates, &c);
  m_internal->m_has_coordinates = true ;
}
/*---------------------------------------------------------------------------*/

bool
PETScMatrix::assemble()
{
  int ierr = 0;
  ierr += MatAssemblyBegin(m_internal->m_internal, MAT_FINAL_ASSEMBLY);
  ierr += MatAssemblyEnd(m_internal->m_internal, MAT_FINAL_ASSEMBLY);
  return (ierr == 0);
}

/*---------------------------------------------------------------------------*/

} // namespace Alien

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

//#pragma clang diagnostic pop
