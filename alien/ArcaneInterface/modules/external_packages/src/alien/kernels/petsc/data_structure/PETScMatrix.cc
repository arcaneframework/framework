#include "PETScMatrix.h"
/* Author : havep at Wed Jul 18 14:46:45 2012
 * Generated by createNew
 */

#include "petscmat.h"
#include <alien/kernels/petsc/data_structure/PETScVector.h>
#include <alien/kernels/petsc/PETScBackEnd.h>
#include <alien/kernels/petsc/data_structure/PETScInternal.h>

#include <alien/core/impl/MultiMatrixImpl.h>

/*---------------------------------------------------------------------------*/

namespace Alien {

/*---------------------------------------------------------------------------*/

PETScMatrix::PETScMatrix(const MultiMatrixImpl* multi_impl)
: IMatrixImpl(multi_impl, AlgebraTraits<BackEnd::tag::petsc>::name())
, m_internal(nullptr)
{
  const auto& row_space = multi_impl->rowSpace();
  const auto& col_space = multi_impl->colSpace();
  if (row_space.size() != col_space.size())
    throw Arccore::FatalErrorException("MTL matrix must be square");
}

/*---------------------------------------------------------------------------*/

PETScMatrix::~PETScMatrix()
{
  delete m_internal;
}

/*---------------------------------------------------------------------------*/

bool
PETScMatrix::initMatrix(const int local_size, const int local_offset,
    const int global_size, Arccore::ConstArrayView<Arccore::Integer> diag_lineSizes,
    Arccore::ConstArrayView<Arccore::Integer> offdiag_lineSizes, const bool parallel)
{
  int ierr = 0; // code d'erreur de retour
  if (m_internal) {
    delete m_internal;
  }
  m_internal = new MatrixInternal(parallel);

  Arccore::Integer max_diag_size = 0, max_offdiag_size = 0;

// -- Matrix --
#ifdef PETSC_HAVE_MATVALID
  PetscTruth valid_flag;
  ierr += MatValid(m_internal->m_internal, &valid_flag);
  if (valid_flag == PETSC_TRUE)
    return (ierr == 0);
#endif /* PETSC_HAVE_MATVALID */

  ierr += MatCreate(PETSC_COMM_WORLD, &m_internal->m_internal);
  ierr += MatSetSizes(
      m_internal->m_internal, local_size, local_size, global_size, global_size);
  ierr += MatSetType(m_internal->m_internal, m_internal->m_type);

  if (parallel) { // Use parallel structures
    ierr += MatMPIAIJSetPreallocation(m_internal->m_internal, max_diag_size,
        diag_lineSizes.unguardedBasePointer(), max_offdiag_size,
        offdiag_lineSizes.unguardedBasePointer());
  } else { // Use sequential structures
    ierr += MatSeqAIJSetPreallocation(
        m_internal->m_internal, max_diag_size, diag_lineSizes.unguardedBasePointer());
  }

  // Offsets are implicit with PETSc, we can to check that
  // they are compatible with the expected behaviour
  PetscInt low;
  ierr += MatGetOwnershipRange(m_internal->m_internal, &low, PETSC_NULL);
  if (low != local_offset)
    return false;

  return (ierr == 0);
}

/*---------------------------------------------------------------------------*/

bool
PETScMatrix::addMatrixValues(
    const int row, const int ncols, const int* cols, const Arccore::Real* values)
{
  int ierr =
      MatSetValues(m_internal->m_internal, 1, &row, ncols, cols, values, ADD_VALUES);
  return (ierr == 0);
}

/*---------------------------------------------------------------------------*/

bool
PETScMatrix::setMatrixValues(
    const int row, const int ncols, const int* cols, const Arccore::Real* values)
{
  int ierr =
      MatSetValues(m_internal->m_internal, 1, &row, ncols, cols, values, INSERT_VALUES);
  return (ierr == 0);
}

/*---------------------------------------------------------------------------*/

bool
PETScMatrix::assemble()
{
  int ierr = 0;
  ierr += MatAssemblyBegin(m_internal->m_internal, MAT_FINAL_ASSEMBLY);
  ierr += MatAssemblyEnd(m_internal->m_internal, MAT_FINAL_ASSEMBLY);
  return (ierr == 0);
}

/*---------------------------------------------------------------------------*/

} // namespace Alien

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

//#pragma clang diagnostic pop
