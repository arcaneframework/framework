/*---------------------------------------------------------------------------*/
/* IfpVtkMeshIOService.cc                                      (C) 2000-2005 */
/*                                                                           */
/* Lecture/Ecriture d'un maillage au format Vtk historique (legacy).         */
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#include <arcane/utils/ArcanePrecomp.h>

#include <arcane/utils/Iostream.h>
#include <arcane/utils/Buffer.h>
#include <arcane/utils/StdHeader.h>
#include <arcane/utils/HashTableMap.h>
#include <arcane/utils/ValueConvert.h>
#include <arcane/utils/ScopedPtr.h>
#include <arcane/utils/ITraceMng.h>
#include <arcane/utils/String.h>
#include <arcane/utils/IOException.h>
#include <arcane/utils/Collection.h>
#include <arcane/utils/Enumerator.h>
#include <arcane/ArcaneVersion.h>

//#include <arcane/utils/Real3.h>

#include <arcane/mesh/DynamicMesh.h>
#include <arcane/mesh/DynamicGraph.h>

#include <arcane/FactoryService.h>
#include <arcane/IMeshReader.h>
#include <arcane/ISubDomain.h>
#include <arcane/IMeshSubMeshTransition.h>
#include <arcane/IItemFamily.h>
#include <arcane/Item.h>
#include <arcane/ItemEnumerator.h>
#include <arcane/VariableTypes.h>
#include <arcane/IVariableAccessor.h>
#include <arcane/IParallelMng.h>
#include <arcane/IIOMng.h>
#include <arcane/IXmlDocumentHolder.h>
#include <arcane/XmlNodeList.h>
#include <arcane/XmlNode.h>

#include <arcane/IMeshUtilities.h>
#include <arcane/IMeshWriter.h>
#include <arcane/BasicService.h>

#include "Utils/Utils.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ARCANE_BEGIN_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class IfpVtkFile;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/*!
 * \brief Lecteur des fichiers de maillage au format Vtk historique (legacy).
 *
 * Il s'agit d'une version pr?liminaire qui ne supporte que les
 * DATASET de type STRUCTURED_GRID ou UNSTRUCTURED_GRID. De plus,
 * le lecteur et l'?crivain n'ont ?t? que partiellement test?s.
 *
 * L'en-t?te du fichier vtk doit ?tre:
 * # vtk DataFile Version 2.0
 *
 * Il est possible de sp?cifier un ensemble de variables dans le fichier.
 * Dans ce cas, leurs valeurs sont lues en m?me temps que le maillage
 * et servent ? initialiser les variables. Actuellement, seules les valeurs
 * aux mailles sont support?es
 *
 * Comme Vtk ne supporte pas la notion de groupe, il est possible
 * de sp?cifier un groupe comme ?tant une variable (CELL_DATA).
 * Par convention, si la variable commence par la chaine 'GROUP_', alors
 * il s'agit d'un groupe. La variable doit ?tre d?clar?e comme suit:
 * \begincode
 * CELL_DATA %n
 * SCALARS GROUP_%m int 1
 * LOOKUP_TABLE default
 * \endcode
 * avec %n le nombre de mailles, et %m le nom du groupe.
 * Une maille appartient au groupe si la valeur de la donn?e est
 * diff?rente de 0.
 *
 * Actuellement, on NE peut PAS specifier de groupes de points.
 *
 * Pour sp?cifier des groupes de faces, il faut un fichier vtk
 * additionnel, identique au fichier d'origine mais contenant la
 * description des faces au lieu des mailles. Par convention, si le
 * fichier courant lu s'appelle 'toto.vtk', le fichier d?crivant les
 * faces sera 'toto.vtkfaces.vtk'. Ce fichier est optionnel.
 */
class IfpVtkMeshIOService
  : public BasicService
  , public IMeshReader
{
public:

  IfpVtkMeshIOService(const ServiceBuildInfo& sbi);

public:

  virtual void build() {}
  ~IfpVtkMeshIOService()
  {
     Integer size;
     size = variable_cell_real.size();
    for(Integer i=0; i<size; i++){
      delete variable_cell_real[i] ;
    }
    size = variable_node_real.size();
    for(Integer i=0; i<size; i++){
      delete variable_node_real[i] ;
    }
  }
public:

  enum eMeshType
    {
      VTK_MT_Unknown,
      VTK_MT_StructuredGrid,
      VTK_MT_DistStructuredGrid,
      VTK_MT_StructuredGraph,
      VTK_MT_StructuredDualGrid,
      VTK_MT_UnstructuredGrid
    };
  class VtkMesh
  {
  public:
  };

  class VtkStructuredGrid
    : public VtkMesh
  {
  public:
    int m_nb_x;
    int m_nb_y;
    int m_nb_z;
  };

public:
  
  virtual bool allowExtension(const String& str)
  {
    return str=="vt2";
  }

public:
  
  virtual eReturnType readMeshFromFile(IWritableMesh* mesh,const XmlNode& mesh_node,const String& file_name,
                                       const String& dir_name,bool use_internal_partition);

  virtual bool hasCutInfos() const { return false; }
  virtual ConstCArrayInteger communicatingSubDomains() const { return ConstCArrayInteger(); }

private:

  bool _readMesh(IWritableMesh* mesh,const String& file_name,const String& dir_name,bool use_internal_partition);
  bool _readStructuredGrid(IWritableMesh* mesh,IfpVtkFile&,bool use_internal_partition);
  bool _readDistStructuredGrid(IWritableMesh* mesh,IfpVtkFile&,bool use_internal_partition);
  bool _readStructuredGraph(IWritableMesh* mesh,IfpVtkFile&,bool use_internal_partition);
  bool _readStructuredDualGrid(IWritableMesh* mesh,IfpVtkFile&,bool use_internal_partition);
  bool _readUnstructuredGrid(IWritableMesh* mesh,IfpVtkFile& vtk_file,bool use_internal_partition);
  void _readNodeVariable(IWritableMesh* mesh,IfpVtkFile& vtk_file,const String& name_str,Integer nb_node);
  void _readCellVariable(IWritableMesh* mesh,IfpVtkFile& vtk_file,const String& name_str,Integer nb_cell);
  void _readItemGroup(IWritableMesh* mesh,IfpVtkFile& vtk_file,const String& name_str,Integer nb_item,
                      eItemKind ik,ConstCArrayInteger local_ids);
  void _createFaceGroup(IMesh* mesh,const String& name,ConstCArrayInteger faces_lid);
  void _createNodeGroup(IMesh* mesh,const String& name,ConstCArrayInteger faces_lid);
  bool _readData(   IWritableMesh* mesh,
                    IfpVtkFile& vtk_file,
                    bool use_internal_partition,
                    CArrayInteger& node_local_ids,
                    CArrayInteger& cell_local_ids,
                    const char * buf = NULL);
  bool _readNodeData(   IWritableMesh* mesh,
                        IfpVtkFile& vtk_file,
                        int nb_node_kind,
                        CArrayInteger& local_ids,
                        const char* buf,
                        istringstream& iline,             
                        std::string& data_str,
                        OCStringStream& created_infos_str) ;
  bool _readCellData(   IWritableMesh* mesh,
                        IfpVtkFile& vtk_file,
                        int nb_cell_kind,
                        CArrayInteger& local_ids,
                        const char* buf,
                        istringstream& iline,             
                        std::string& data_str,
                        OCStringStream& created_infos_str);
  bool _readFaceData(IWritableMesh* mesh,IfpVtkFile& vtk_file,bool use_internal_partition,eItemKind cell_kind,
                     ConstCArrayInteger local_ids);
  bool _createGraphLinkType(    IWritableMesh* mesh,
                                bool use_internal_partition,
                                CArrayInteger& cell_local_ids,
                                CArrayInteger& link_type) ;             
  void _writeMeshToFile(IWritableMesh* mesh,const String& file_name,eItemKind cell_kind);
  void _readNodesUnstructuredGrid(IWritableMesh* mesh,IfpVtkFile& vtk_file,CArrayReal3& node_coords);
  void _readCellsUnstructuredGrid(IWritableMesh* mesh,IfpVtkFile& vtk_file,
                                  CArrayInteger& cells_nb_node,
                                  CArrayInteger& cells_type,
                                  CArrayInt64& cells_connectivity);
  void _readFacesMesh(IWritableMesh* mesh,const String& file_name,
                      const String& dir_name,bool use_internal_partition);
  void _readStructuredFacesMesh(IWritableMesh* mesh,const String& file_name,
                                const String& dir_name,bool use_internal_partition);

  void _readDistStructuredFacesMesh(IWritableMesh* mesh,const String& file_name,
                                const String& dir_name,bool use_internal_partition);
  bool check(Integer i, Integer j, Integer k,Integer nx, Integer ny, Integer nz) ;
  void _createItemGroup(IMesh* mesh,
                        IfpVtkFile& vtk_file,
                        const char* buf,
                        Integer nb_item_x,
                        Integer nb_item_y,
                        Integer nb_item_z,
                        Integer first_x,
                        Integer local_nb_item_x,
                        Integer first_y,
                        Integer local_nb_item_y,
                        eItemKind ik,
                        bool use_internal_partition) ;
  void _computePartition(Integer nproc,Integer* np1, Integer* np2) ;
  BufferT< VariableCellReal * > variable_cell_real;
  BufferT< VariableNodeReal * > variable_node_real;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class IfpVtkFile
{
public:
  static const int BUFSIZE = 10000;
public:
  enum LINE_TYPE { OPTIONAL_LINE, MANDATORY_LINE };
public:
  IfpVtkFile(istream* stream) : m_stream(stream) {}
  const bool isThereAnotherLine();
  const char* getNextLine(LINE_TYPE line_type);
  Real getReal();
  Integer getInteger();
  void checkString(const String& current_value,const String& expected_value);
  void checkString(const String& current_value,
                   const String& expected_value1,
                   const String& expected_value2);
  static bool isEqualString(const String& current_value,const String& expected_value);

  bool isEnd(){ (*m_stream) >> ws; return m_stream->eof(); }
private:
  istream* m_stream;
  char m_buf[BUFSIZE];
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

const char* IfpVtkFile::
getNextLine(LINE_TYPE line_type = MANDATORY_LINE)
{
  while (m_stream->good()){
    m_stream->getline(m_buf,sizeof(m_buf)-1);
    if (m_stream->eof())
      break;
    bool is_comment = true;
    if (m_buf[0]=='\n' || m_buf[0]=='\r')
      continue;
    // Regarde si un caract?re de commentaire est pr?sent
    for( int i=0; i<BUFSIZE && m_buf[i]!='\0'; ++i ){
      if (!isspace(m_buf[i])){
        is_comment = (m_buf[i]=='#');
        break;
      }
    }
    if (!is_comment){
      
      // Supprime le '\n' ou '\r' final
      for( int i=0; i<BUFSIZE && m_buf[i]!='\0'; ++i ){
        //cout << " V=" << m_buf[i] << " I=" << (int)m_buf[i] << "\n";
        if (m_buf[i]=='\n' || m_buf[i]=='\r'){
          m_buf[i] = '\0';
          break;
        }
      }
      return m_buf;
    }
  }

  if(line_type == MANDATORY_LINE)
    throw IOException("IfpVtkFile::getNexLine()","Unexpected EndOfFile");
  return NULL;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

Real IfpVtkFile::
getReal()
{
  Real v = 0.;
  (*m_stream) >> ws >> v;
  if (m_stream->good())
    return v;
  throw IOException("IfpVtkFile::getReal()","Bad Real");
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

Integer IfpVtkFile::
getInteger()
{
  Integer v = 0;
  (*m_stream) >> ws >> v;
  if (m_stream->good())
    return v;
  throw IOException("IfpVtkFile::getInteger()","Bad Integer");
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void IfpVtkFile::
checkString(const String& current_value,const String& expected_value)
{
  String current_value_low = current_value.clone(); 
  current_value_low.toLower();
  String expected_value_low = expected_value.clone(); 
  expected_value_low.toLower();
 
  if (current_value_low!=expected_value_low){
    String s = "Attend chaine '" + expected_value + "', trouve '" + current_value + "'";
    throw IOException("IfpVtkFile::checkString()",s);
  }
}

void IfpVtkFile::
checkString(const String& current_value,const String& expected_value1,const String& expected_value2)
{
  String current_value_low = current_value.clone(); 
  current_value_low.toLower();
  String expected_value1_low = expected_value1.clone();
  expected_value1_low.toLower();
  String expected_value2_low = expected_value2.clone(); 
  expected_value2_low.toLower();

  if (current_value_low!=expected_value1_low and current_value_low!=expected_value2_low){
    String s = "Attend chaine '" + expected_value1 + "' ou '"
      + expected_value2 + "', trouve '" + current_value + "'";
    throw IOException("IfpVtkFile::checkString()",s);
  }
}

bool IfpVtkFile::
isEqualString(const String& current_value,const String& expected_value)
{
  String current_value_low = current_value.clone(); 
  current_value_low.toLower();
  String expected_value_low = expected_value.clone(); 
  expected_value_low.toLower();
  return (current_value_low==expected_value_low);
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ARCANE_REGISTER_SUB_DOMAIN_FACTORY(IfpVtkMeshIOService,IMeshReader,IfpVtkMeshIO);

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
IfpVtkMeshIOService::
IfpVtkMeshIOService(const ServiceBuildInfo& sbi)
  : BasicService(sbi)
{
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/*!
 * \todo Verifier plantage sous linux.
 */
IMeshReader::eReturnType IfpVtkMeshIOService::
readMeshFromFile(IWritableMesh* mesh,const XmlNode& mesh_node,
                 const String& filename,const String& dir_name,
                 bool use_internal_partition)
{
 
  bool ret = _readMesh(mesh,filename,dir_name,use_internal_partition);
  if (ret)
    return RTError;

  return RTOk;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

bool IfpVtkMeshIOService::
_readMesh(IWritableMesh* mesh,const String& file_name,const String& dir_name,bool use_internal_partition)
{
  ifstream ifile(file_name.localstr());
  if (!ifile){
    error() << "Impossible d'ouvrir en lecture le fichier '" << file_name << "'";
    return true;
  }
  IfpVtkFile vtk_file(&ifile);
  const char* buf = 0;
  // Lecture de la description
  buf = vtk_file.getNextLine();
  String format = vtk_file.getNextLine();
  if (not IfpVtkFile::isEqualString(format,"ASCII")){
    error() << "Seul le format 'ASCII' est reconnu (format='" << format << "')";
    return true;
  }
  eMeshType mesh_type = VTK_MT_Unknown;
  // Lecture du type de maillage
  // TODO: en parall?le, avec use_internal_partition vrai, seul le processeur 0
  // lit les donn?es. Dans ce cas, inutile que les autres ouvre le fichier.
  {
    buf = vtk_file.getNextLine();
    istringstream mesh_type_line(buf);
    std::string dataset_str;
    std::string mesh_type_str;
    mesh_type_line >> ws >> dataset_str >> ws >> mesh_type_str;
    vtk_file.checkString(dataset_str,"DATASET");
    if (IfpVtkFile::isEqualString(mesh_type_str,"STRUCTURED_GRID")){
      mesh_type = VTK_MT_StructuredGrid;
    }
    if (IfpVtkFile::isEqualString(mesh_type_str,"DIST_STRUCTURED_GRID")){
      mesh_type = VTK_MT_DistStructuredGrid;
    }
    if (IfpVtkFile::isEqualString(mesh_type_str,"STRUCTURED_GRAPH")){
      mesh_type = VTK_MT_StructuredGraph;
    }
    if (IfpVtkFile::isEqualString(mesh_type_str,"STRUCTURED_DUALGRID")){
      mesh_type = VTK_MT_StructuredDualGrid;
    }
    if (IfpVtkFile::isEqualString(mesh_type_str,"UNSTRUCTURED_GRID")){
      mesh_type = VTK_MT_UnstructuredGrid;
    }
    if (mesh_type==VTK_MT_Unknown){
      error() << "Seul les formats 'STRUCTURED_GRID' et 'UNSTRUCTURED_GRID' sont implementes (format=" << mesh_type_str << "')";
      return true;
    }
  }
  bool ret = true;
  switch(mesh_type){
  case VTK_MT_StructuredGrid:
    ret = _readStructuredGrid(mesh,vtk_file,use_internal_partition);
    if (!ret){
      // Tente de lire le fichier des faces s'il existe
      _readStructuredFacesMesh(mesh,file_name+"faces.vt2",dir_name,use_internal_partition);
    }
    break;
  case VTK_MT_DistStructuredGrid:
    ret = _readDistStructuredGrid(mesh,vtk_file,use_internal_partition);
    if (!ret){
      // Tente de lire le fichier des faces s'il existe
      _readDistStructuredFacesMesh(mesh,file_name+"faces.vt2",dir_name,use_internal_partition);
    }
    break;
  case VTK_MT_StructuredGraph:
    ret = _readStructuredGraph(mesh,vtk_file,use_internal_partition);
    break;
  case VTK_MT_StructuredDualGrid:
    ret = _readStructuredDualGrid(mesh,vtk_file,use_internal_partition);
    break;
  case VTK_MT_UnstructuredGrid:
    ret = _readUnstructuredGrid(mesh,vtk_file,use_internal_partition);
    if (!ret){
      // Tente de lire le fichier des faces s'il existe
      _readFacesMesh(mesh,file_name+"faces.vtk2",dir_name,use_internal_partition);
    }
    break;
  case VTK_MT_Unknown:
    break;
  }
  /*while ( (buf=vtk_file.getNextLine()) != 0 ){
    info() << " STR " << buf;
    }*/
  return ret;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

bool IfpVtkMeshIOService::
_readStructuredGrid(IWritableMesh* mesh,IfpVtkFile& vtk_file,bool use_internal_partition)
{
  // IParallelMng* pm = subDomain()->parallelMng();

  ////////////////////////////////////////////////////////////
  // Lecture des paramètres obligatoires

  // Lecture du nombre de points: DIMENSIONS nx ny nz
  const char* buf = 0;
  Integer nb_node_x = 0;
  Integer nb_node_y = 0;
  Integer nb_node_z = 0;
  {
    buf = vtk_file.getNextLine();
    istringstream iline(buf);
    std::string dimension_str;
    iline >> ws >> dimension_str >> ws >> nb_node_x
          >> ws >> nb_node_y >> ws >> nb_node_z;
    if (!iline){
      error() << "Erreur de syntaxe lors de la lecture des dimensions de la grille";
      return true;
    }
    vtk_file.checkString(dimension_str,"DIMENSIONS");
    if (nb_node_x<0 || nb_node_y<0 || nb_node_z<0 || nb_node_x+nb_node_y+nb_node_z<1){
      error() << "Dimensions invalides: x=" << nb_node_x << " y=" << nb_node_y << " z=" << nb_node_z;
      return true;
    }
  }
  
  info() << "Nombre de noeuds (x, y, z) = (" 
         << nb_node_x << ", "
         << nb_node_y << ", " 
         << nb_node_z << ")";
  Integer nb_node = nb_node_x * nb_node_y * nb_node_z;

  Real Ox = 0. ;
  Real Oy = 0. ;
  Real Oz = 0. ;
  Real dx = 0. ;
  Real dy = 0. ;
  Real dz = 0. ;
  Array<Real> dzf ;
  bool top_def = false ;
  bool dz_def = false ;
  bool top_file_read = false ;
  bool dz_file_read = false ;
  bool layer_top = false ;
  std::string top_file_str("Undefined") ;
  std::string dz_file_str("Undefined") ;
  // Lecture du nombre de points: POINTS nb float
  {
    buf = vtk_file.getNextLine();
    istringstream iline(buf);
    std::string origin_str;
    iline >> ws >> origin_str ;
    if(IfpVtkFile::isEqualString(origin_str,"ORIGIN"))
    {
      iline >> ws >> Ox >> ws >> Oy >> ws >> Oz;
      if (!iline){
        error() << "Erreur de syntaxe lors de la lecture des dimensions de la grille";
        return true;
      }
    }
    else
    {
      top_def = true ;
      if(IfpVtkFile::isEqualString(origin_str,"TOP"))
        {
          iline >> ws >> top_file_str ;
          if (!iline){
            error() << "Erreur de syntaxe lors de la lecture des données toit";
            return true;
          }
        }
    }
    vtk_file.checkString(origin_str,"ORIGIN","TOP");
  }
  {
    buf = vtk_file.getNextLine();
    istringstream iline(buf);
    std::string step_str;
    iline >> ws >> step_str ;
    if(IfpVtkFile::isEqualString(step_str,"DXYZ"))
    {
      iline >> ws >> dx >> ws >> dy >> ws >> dz;
      if (!iline){
        error() << "Erreur de syntaxe lors de la lecture des dimensions de la grille";
        return true;
      }
      layer_top = (dz<0) ;
    } 
    else if(IfpVtkFile::isEqualString(step_str,"STEP"))
    {
      warning() << "STEP keyword is deprecated; use DXYZ instead.";
      iline >> ws >> dx >> ws >> dy >> ws >> dz;
      if (!iline){
        error() << "Erreur de syntaxe lors de la lecture des dimensions de la grille";
        return true;
      }
      layer_top = (dz<0) ;
    } 
    else if(IfpVtkFile::isEqualString(step_str,"DXY"))
      {
        iline >> ws >> dx >> ws >> dy  ;
        if (!iline){
          error() << "Erreur de syntaxe lors de la lecture des dimensions de la grille";
          return true;
        }
        buf = vtk_file.getNextLine();
        istringstream iline2(buf);
        std::string stepz_str;
        iline2 >> ws >> stepz_str ;
        if(IfpVtkFile::isEqualString(stepz_str,"DZ"))
          {
            iline2 >> ws >> dz;
            if (!iline2){
              error() << "Erreur de syntaxe lors de la lecture des dimensions de la grille";
              return true;
            }
            layer_top = (dz<0) ;
          }
        else
          {
            if(IfpVtkFile::isEqualString(stepz_str,"DZFILE"))
            {
              dz_def = true ;
              iline2 >> ws >> dz_file_str;
              if (!iline2){
                error() << "Erreur de syntaxe lors de la lecture des dimensions de la grille";
                return true;
              }
              dzf.resize(nb_node_z) ;
              dz_file_read = readBufferFromFile(dz_file_str,dzf,nb_node_z);
	      if (!dz_file_read) {
		error() << "Erreur de lecture du fichier DZFILE : " << dz_file_str;
		return true;
	      }
              layer_top = (dzf[0]<0) ;
            }
          }
      } 
    else 
    {
      // STEP est volontairement non listé dans l'ensemble des mots clefs car deprecated
      vtk_file.checkString(step_str,"DXYZ","DXY");
    }
  }
  
  Integer sub_domain_id = subDomain()->subDomainId();

  Integer nb_cell_x = nb_node_x-1;
  Integer nb_cell_y = nb_node_y-1;
  Integer nb_cell_z = nb_node_z-1;

  if (use_internal_partition && sub_domain_id!=0){
    nb_node_x = 0;
    nb_node_y = 0;
    nb_node_z = 0;
    nb_cell_x = 0;
    nb_cell_y = 0;
    nb_cell_z = 0;
  }
  
  Integer nb_node_yz = nb_node_y*nb_node_z;
  Integer nb_node_xy = nb_node_x*nb_node_y;

  Integer nb_cell = nb_cell_x * nb_cell_y * nb_cell_z;
  CArrayInteger cells_local_id(nb_cell);
  CArrayInteger nodes_local_id(nb_node);

  ////////////////////////////////////////////////////////////
  // Creation du maillage

  {
    CArrayInteger nodes_unique_id(nb_node);

    info() << " NODE YZ = " << nb_node_yz;
    // Cr?ation des noeuds
    Integer nb_node_local_id = 0;
    {
      Integer node_local_id = 0;
      for( Integer z=0; z<nb_node_z; ++z ){
        for( Integer y=0; y<nb_node_y; ++y ){
          for( Integer x=0; x<nb_node_x; ++x ){
    
            Integer node_unique_id = x + (y)*nb_node_x + z*nb_node_x*nb_node_y;
          
            nodes_unique_id[node_local_id] = node_unique_id;
            //Integer owner = sub_domain_id;
            //nodes_local_id[node_local_id] = node_local_id;
            
            ++node_local_id;
          }
        }
      }
      nb_node_local_id = node_local_id;
      warning() << " NB NODE LOCAL ID=" << node_local_id;
    }

    // Cr?ation des mailles
    
    // Infos pour la cr?ation des mailles
    // par maille: 1 pour son unique id,
    //             1 pour son type,
    //             8 pour chaque noeud
    CArrayInt64 cells_infos(nb_cell*10);
    Integer off_layer = 0 ;
    if(layer_top)
      off_layer = 4 ;
    {
      Integer cell_local_id = 0;
      Integer cells_infos_index = 0;

      for( Integer z=0; z<nb_cell_z; ++z ){
        for( Integer y=0; y<nb_cell_y; ++y ){
          for( Integer x=0; x<nb_cell_x; ++x ){
            Integer current_cell_nb_node = 8;
          
            //Integer cell_unique_id = y + (z)*nb_cell_y + x*nb_cell_y*nb_cell_z;
            Int64 cell_unique_id = x + y*nb_cell_x + z*nb_cell_x*nb_cell_y;
          
            cells_infos[cells_infos_index] = IT_Hexaedron8;
            ++cells_infos_index;

            cells_infos[cells_infos_index] = cell_unique_id;
            ++cells_infos_index;

            //Integer base_id = y + z*nb_node_y + x*nb_node_yz;
            Integer base_id = x + y*nb_node_x + z*nb_node_xy;
            cells_infos[cells_infos_index+0+off_layer] = nodes_unique_id[base_id];
            cells_infos[cells_infos_index+1+off_layer] = nodes_unique_id[base_id + 1];
            cells_infos[cells_infos_index+2+off_layer] = nodes_unique_id[base_id + nb_node_x + 1];
            cells_infos[cells_infos_index+3+off_layer] = nodes_unique_id[base_id + nb_node_x + 0];
            cells_infos[cells_infos_index+4-off_layer] = nodes_unique_id[base_id + nb_node_xy];
            cells_infos[cells_infos_index+5-off_layer] = nodes_unique_id[base_id + nb_node_xy + 1];
            cells_infos[cells_infos_index+6-off_layer] = nodes_unique_id[base_id + nb_node_xy + nb_node_x + 1];
            cells_infos[cells_infos_index+7-off_layer] = nodes_unique_id[base_id + nb_node_xy + nb_node_x + 0];
            cells_infos_index += current_cell_nb_node;
            cells_local_id[cell_local_id] = cell_local_id;
            ++cell_local_id;
          }
        }
      }
    }

    mesh->setDimension(3) ;
    mesh->allocateCells(nb_cell,cells_infos,false);
    mesh->endAllocate();
    
    // Positionne les coordonn?es
    {
      Array<Real3> coords(nb_node);
      Array<Real> topz ;
      Array<Real> dzf ; 
      if (sub_domain_id==0){
      if(top_def)
      {
        topz.resize(nb_node_y*nb_node_x) ;
        top_file_read = readBufferFromFile(top_file_str,topz,nb_node_y*nb_node_x);
	if (!top_file_read)  
	  {
	    error() << "Erreur de lecture du fichier TOP : " << top_file_str;
	    return true; 
	  } 
      }
      if(dz_def)
      {
        dzf.resize(nb_node_z) ;
        dz_file_read = readBufferFromFile(dz_file_str,dzf,nb_node_z) ;
	if (!dz_file_read)  
	  {
	    error() << "Erreur de lecture du fichier DZFILE : " << dz_file_str;
	    return true; 
	  } 
      }
      Real nz = Oz ;
      Real tz = 0. ;
      for( Integer z=0; z<nb_node_z; ++z )
        {
          Real ny = Oy ;
          for( Integer y=0; y<nb_node_y; ++y )
            {
              Real nx = Ox ;
              for( Integer x=0; x<nb_node_x; ++x )
                {
                  Integer node_unique_id = x + y*nb_node_x + z*nb_node_xy;
                  if(top_def) tz = topz[y*nb_node_x+x] ;
                  coords[node_unique_id] = Real3(nx,ny,nz+tz);
                  nx += dx ;
                }
              ny += dy ;
            }
          nz += dz ;
          if(dz_def) nz += dzf[z] ;
        }
      }
      VariableNodeReal3& nodes_coord_var(mesh->nodesCoordinates());
      ENUMERATE_NODE(inode,mesh->allNodes()){
        const Node& node = *inode;
        nodes_coord_var[inode] = coords[node.uniqueId()];
      }
    }
  }

  // Cr?? les groupes de faces des c?t?s du parall?l?pip?de
  BufferT<Integer> xmin_surface_lid;
  BufferT<Integer> xmax_surface_lid;
  BufferT<Integer> ymin_surface_lid;
  BufferT<Integer> ymax_surface_lid;
  BufferT<Integer> zmin_surface_lid;
  BufferT<Integer> zmax_surface_lid;

  ENUMERATE_FACE(iface,mesh->allFaces()){
    const Face& face = *iface;
    Integer face_local_id = face.localId();
    bool is_xmin = true;
    bool is_xmax = true;
    bool is_ymin = true;
    bool is_ymax = true;
    bool is_zmin = true;
    bool is_zmax = true;
    for( NodeEnumerator inode(face.nodes()); inode(); ++inode ){
      const Node& node = *inode;
      Int64 node_unique_id = node.uniqueId();
      Int64 node_z = node_unique_id / nb_node_xy;
      Int64 node_y = (node_unique_id - node_z*nb_node_xy) / nb_node_x;
      Int64 node_x = node_unique_id - node_z*nb_node_xy - node_y*nb_node_x;
      if (node_x!=0)
        is_xmin = false;
      if (node_x!=(nb_node_x-1))
        is_xmax = false;
      if (node_y!=0)
        is_ymin = false;
      if (node_y!=(nb_node_y-1))
        is_ymax = false;
      if (node_z!=0)
        is_zmin = false;
      if (node_z!=(nb_node_z-1))
        is_zmax = false;
    }
    if (is_xmin)
      xmin_surface_lid.add(face_local_id);
    if (is_xmax)
      xmax_surface_lid.add(face_local_id);
    if (is_ymin)
      ymin_surface_lid.add(face_local_id);
    if (is_ymax)
      ymax_surface_lid.add(face_local_id);
    if (is_zmin)
      zmin_surface_lid.add(face_local_id);
    if (is_zmax)
      zmax_surface_lid.add(face_local_id);
      
  }
  _createFaceGroup(mesh,"XMIN",xmin_surface_lid);
  _createFaceGroup(mesh,"XMAX",xmax_surface_lid);
  _createFaceGroup(mesh,"YMIN",ymin_surface_lid);
  _createFaceGroup(mesh,"YMAX",ymax_surface_lid);
  _createFaceGroup(mesh,"ZMIN",zmin_surface_lid);
  _createFaceGroup(mesh,"ZMAX",zmax_surface_lid);

  ////////////////////////////////////////////////////////////
  // Lecture des paramètres optionnels

  info() << "Lecture des paramètres optionnels";

  std::string tag_zmin = "DEFAULT";
  std::string tag_zmax = "DEFAULT";
  std::string tag_ymin = "DEFAULT";
  std::string tag_ymax = "DEFAULT";
  std::string tag_xmin = "DEFAULT";
  std::string tag_xmax = "DEFAULT";

  bool ok = true ;
  do {
    buf = vtk_file.getNextLine(IfpVtkFile::OPTIONAL_LINE);
    if( buf == NULL ) break;
    istringstream iline(buf);

    // Lis le mot clé
    std::string keyword;
    iline >> ws >> keyword;

    if( IfpVtkFile::isEqualString(keyword,"TAGS") ) {
      // Lecture des étiquettes associées aux faces du parallélépipède
      // pour le conditions au bord dans l'ordre suivant:
      // z = zmin, z = zmax, y = ymin, y = ymax, x = xmin, x = xmax  

      iline >> ws >> tag_zmin >> ws >> tag_zmax
            >> ws >> tag_ymin >> ws >> tag_ymax
            >> ws >> tag_xmin >> ws >> tag_xmax;
      if(!iline) {
        error() << "Erreur de syntaxe lors de la lecture des étiquettes associées aux faces de bord";
        return true;
      }
      info() << "Etiquettes associées aux faces de bord:";
      info() << "(z = zmin, z = zmax, y = ymin, y = ymax, x = xmin, x = xmax) = ("
             << tag_zmin << ", " << tag_zmax << ", "
             << tag_ymin << ", " << tag_ymax << ", "
             << tag_xmin << ", " << tag_xmax << ")";
    } else if( IfpVtkFile::isEqualString(keyword,"CELLGROUPS") ) {
      Integer nb_groups = 0 ;
      iline >> ws >> nb_groups;
      if (!iline){
        error() << "Erreur de syntaxe lors de la lecture des groupes de cellules";
        return true;
      }
      for(Integer igroup = 0; igroup < nb_groups; igroup++)
        _createItemGroup(mesh, vtk_file, buf, nb_cell_x, nb_cell_y, nb_cell_z, 
                         0,nb_cell_x,0,nb_cell_y,IK_Cell,
                         use_internal_partition);
    } else if( IfpVtkFile::isEqualString(keyword,"NODEGROUPS") ) {
      Integer nb_groups = 0 ;
      iline >> ws >> nb_groups;
      if (!iline){
        error() << "Erreur de syntaxe lors de la lecture des groupes de noeuds";
        return true;
      }
      for(Integer igroup=0;igroup<nb_groups;igroup++)
        _createItemGroup(mesh, vtk_file, buf, nb_node_x, nb_node_y, nb_node_z, 
                         0,nb_node_x,0,nb_node_y,IK_Node,
                         use_internal_partition);
    } else if( IfpVtkFile::isEqualString(keyword,"FACEGROUPS") ) {
      Integer nb_groups = 0 ;
      iline >> ws >> nb_groups;
      if (!iline){
        error() << "Erreur de syntaxe lors de la lecture des groupes de faces";
        return true;
      }
      for(Integer igroup=0;igroup<nb_groups;igroup++)
        _createItemGroup(mesh, vtk_file, buf, nb_cell_x, nb_cell_y, nb_cell_z, 
                         0,nb_cell_x,0,nb_cell_y,IK_Face,
                         use_internal_partition);
    } else if( (IfpVtkFile::isEqualString(keyword,"CELL_DATA")  ) || 
               (IfpVtkFile::isEqualString(keyword,"POINT_DATA") )   ) {
      // Maintenant, regarde s'il existe des données associées cell aux fichiers
        ok = _readData( mesh,
                            vtk_file,
                            use_internal_partition,
                            nodes_local_id,
                            cells_local_id,
                            buf );
        if(ok) return true ;
    } else {
      error() << "Mot clé [" << keyword << "] inconnu";
      return true;
    }
  } while( ok );

  // Create face groups for boundary conditions
  // The prefix "BC_" is added to the boundary condition name by default 
  // in order to avoid group name collisions
  info() << "Création des groupes pour les conditions au bord";

  if( mesh->findGroup( "BC_" + tag_zmin ).null() )
    _createFaceGroup(mesh, "BC_" + tag_zmin, zmin_surface_lid);
  else
    error() << "FATAL: Group with reserved name BC_" + tag_zmin
            << " already exists";

  if( mesh->findGroup( "BC_" + tag_zmax ).null() )
    _createFaceGroup(mesh, "BC_" + tag_zmax, zmax_surface_lid);
  else
    mesh->findGroup( "BC_" + tag_zmax ).addItems( zmax_surface_lid );

  if( mesh->findGroup( "BC_" + tag_ymin ).null() )
    _createFaceGroup(mesh, "BC_" + tag_ymin, ymin_surface_lid);
  else
    mesh->findGroup( "BC_" + tag_ymin ).addItems( ymin_surface_lid );

  if( mesh->findGroup( "BC_" + tag_ymax ).null() )
    _createFaceGroup(mesh, "BC_" + tag_ymax, ymax_surface_lid);
  else
    mesh->findGroup( "BC_" + tag_ymax ).addItems( ymax_surface_lid );

  if( mesh->findGroup( "BC_" + tag_xmin ).null() )
    _createFaceGroup(mesh, "BC_" + tag_xmin, xmin_surface_lid);
  else
    mesh->findGroup( "BC_" + tag_xmin ).addItems( xmin_surface_lid );

  if( mesh->findGroup( "BC_" + tag_xmax ).null() )
    _createFaceGroup(mesh, "BC_" + tag_xmax, xmax_surface_lid);
  else
    mesh->findGroup( "BC_" + tag_xmax ).addItems( xmax_surface_lid );
  
  return false ;
}


bool IfpVtkMeshIOService::
_readStructuredGraph(IWritableMesh* mesh,IfpVtkFile& vtk_file,bool use_internal_partition)
{
  // IParallelMng* pm = subDomain()->parallelMng();
  // Lecture du nombre de points: DIMENSIONS nx ny nz
  info()<<"readStructuredGraph :"<<use_internal_partition;
  const char* buf = 0;
  Integer nb_node_x = 0;
  Integer nb_node_y = 0;
  Integer nb_node_z = 0;
  {
    buf = vtk_file.getNextLine();
    istringstream iline(buf);
    std::string dimension_str;
    iline >> ws >> dimension_str >> ws >> nb_node_x
          >> ws >> nb_node_y >> ws >> nb_node_z;
    if (!iline){
      error() << "Erreur de syntaxe lors de la lecture des dimensions de la grille";
      return true;
    }
    vtk_file.checkString(dimension_str,"DIMENSIONS");
    if (nb_node_x<0 || nb_node_y<0 || nb_node_z<0 || nb_node_x+nb_node_y+nb_node_z<1){
      error() << "Dimensions invalides: x=" << nb_node_x << " y=" << nb_node_y << " z=" << nb_node_z;
      return true;
    }
  }
  info() << " Infos: " << nb_node_x << " " << nb_node_y << " " << nb_node_z;
  Real Ox = 0. ;
  Real Oy = 0. ;
  Real Oz = 0. ;
  Real dx = 0. ;
  Real dy = 0. ;
  Real dz = 0. ;
  // Lecture du nombre de points: POINTS nb float
  {
    buf = vtk_file.getNextLine();
    istringstream iline(buf);
    std::string origin_str;
    iline >> ws >> origin_str >> ws >> Ox >> ws >> Oy >> ws >> Oz;
    if (!iline){
      error() << "Erreur de syntaxe lors de la lecture des dimensions de la grille";
      return true;
    }
    vtk_file.checkString(origin_str,"ORIGIN");
  }
  {
    buf = vtk_file.getNextLine();
    istringstream iline(buf);
    std::string step_str;
    iline >> ws >> step_str >> ws >> dx >> ws >> dy >> ws >> dz;
    if (!iline){
      error() << "Erreur de syntaxe lors de la lecture des dimensions de la grille";
      return true;
    }
    vtk_file.checkString(step_str,"STEP");
  }

  Integer sub_domain_id = subDomain()->subDomainId();

  Integer nb_cell_x = nb_node_x-1;
  Integer nb_cell_y = nb_node_y-1;
  Integer nb_cell_z = nb_node_z-1;

  if (use_internal_partition && sub_domain_id!=0){
    nb_node_x = 0;
    nb_node_y = 0;
    nb_node_z = 0;
    nb_cell_x = 0;
    nb_cell_y = 0;
    nb_cell_z = 0;
  }

  Integer nb_node_xz = nb_node_x*nb_node_z;
  Integer nb_node_yz = nb_node_y*nb_node_z;
  Integer nb_node_xy = nb_node_x*nb_node_y;

  Integer nb_node = nb_node_x * nb_node_y * nb_node_z;
  Integer nb_cell = nb_cell_x * nb_node_yz +
    nb_cell_y * nb_node_xz +
    nb_cell_z * nb_node_xy ;
  CArrayInteger cells_local_id(nb_cell);
  CArrayInteger links_type(nb_cell);
  CArrayInteger nodes_local_id(nb_node);

  // Creation du maillage
  {
    CArrayInteger nodes_unique_id(nb_node);

    info() << " NODE YZ = " << nb_node_yz;
    // Cr?ation des noeuds
    Integer nb_node_local_id = 0;
    {
      Integer node_local_id = 0;
      for( Integer z=0; z<nb_node_z; ++z ){
        for( Integer y=0; y<nb_node_y; ++y ){
          for( Integer x=0; x<nb_node_x; ++x ){
    
            Integer node_unique_id = x + (y)*nb_node_x + z*nb_node_x*nb_node_y;
          
            nodes_unique_id[node_local_id] = node_unique_id;
            nodes_local_id[node_local_id] = node_local_id;
            
            ++node_local_id;
          }
        }
      }
      nb_node_local_id = node_local_id;
      warning() << " NB NODE LOCAL ID=" << node_local_id;
    }

    // Cr?ation des mailles
    
    // Infos pour la cr?ation des mailles
    // par maille: 1 pour son unique id,
    //             1 pour son type,
    //             2 pour chaque noeud
    CArrayInt64 cells_infos(nb_cell*4) ;
    {
      Integer cell_local_id = 0;
      Integer cells_infos_index = 0;
      Integer current_cell_nb_node = 2;

      for( Integer z=0; z<nb_node_z; ++z ){
        for( Integer y=0; y<nb_node_y; ++y ){
          for( Integer x=0; x<nb_cell_x; ++x ){
          
            //Integer cell_unique_id = y + (z)*nb_cell_y + x*nb_cell_y*nb_cell_z;
            Integer cell_unique_id = x + y*nb_cell_x + z*nb_cell_x*nb_node_y ;
          
            cells_infos[cells_infos_index] = IT_Line2;
            ++cells_infos_index;

            cells_infos[cells_infos_index] = cell_unique_id;
            ++cells_infos_index;

            //Integer base_id = y + z*nb_node_y + x*nb_node_yz;
            Integer base_id = x + y*nb_node_x + z*nb_node_xy;
            cells_infos[cells_infos_index+0] = nodes_unique_id[base_id];
            cells_infos[cells_infos_index+1] = nodes_unique_id[base_id + 1];
            cells_infos_index += current_cell_nb_node;
            cells_local_id[cell_local_id] = cell_local_id;
            links_type[cell_local_id] = 0 ;
            ++cell_local_id;
          }
        }
      }
      Integer ptr_j = nb_cell_x * nb_node_yz ;
      for( Integer z=0; z<nb_node_z; ++z ){
        for( Integer y=0; y<nb_cell_y; ++y ){
          for( Integer x=0; x<nb_node_x; ++x ){
          
            //Integer cell_unique_id = y + (z)*nb_cell_y + x*nb_cell_y*nb_cell_z;
            Integer cell_unique_id = ptr_j + x + y*nb_node_x + z*nb_node_x*nb_cell_y;
          
            cells_infos[cells_infos_index] = IT_Line2;
            ++cells_infos_index;

            cells_infos[cells_infos_index] = cell_unique_id;
            ++cells_infos_index;

            //Integer base_id = y + z*nb_node_y + x*nb_node_yz;
            Integer base_id = x + y*nb_node_x + z*nb_node_xy;
            cells_infos[cells_infos_index+0] = nodes_unique_id[base_id];
            cells_infos[cells_infos_index+1] = nodes_unique_id[base_id + nb_node_x + 0];
            cells_infos_index += current_cell_nb_node;
            cells_local_id[cell_local_id] = cell_local_id;
            links_type[cell_local_id] = 1 ;
            ++cell_local_id;
          }
        }
      }
      Integer ptr_k = nb_cell_x * nb_node_yz + nb_cell_y*nb_node_xz ;
      for( Integer z=0; z<nb_cell_z; ++z ){
        for( Integer y=0; y<nb_node_y; ++y ){
          for( Integer x=0; x<nb_node_x; ++x ){
          
            //Integer cell_unique_id = y + (z)*nb_cell_y + x*nb_cell_y*nb_cell_z;
            Integer cell_unique_id = ptr_k + x + y*nb_node_x + z*nb_node_x*nb_node_y;
          
            cells_infos[cells_infos_index] = IT_Line2;
            ++cells_infos_index;

            cells_infos[cells_infos_index] = cell_unique_id;
            ++cells_infos_index;

            //Integer base_id = y + z*nb_node_y + x*nb_node_yz;
            Integer base_id = x + y*nb_node_x + z*nb_node_xy;
            cells_infos[cells_infos_index+0] = nodes_unique_id[base_id];
            cells_infos[cells_infos_index+1] = nodes_unique_id[base_id + nb_node_xy];
            cells_infos_index += current_cell_nb_node;
            cells_local_id[cell_local_id] = cell_local_id;
            links_type[cell_local_id] = 2 ;
            ++cell_local_id;
          }
        }
      }
    }

    mesh->setDimension(3);
    mesh->allocateCells(nb_cell,cells_infos,false);
    mesh->endAllocate();

    //Real Ox = vtk_file.getReal();
    //Real Oy = vtk_file.getReal();
    //Real Oz = vtk_file.getReal();
    //Real dx = vtk_file.getReal();
    //Real dy = vtk_file.getReal();
    //Real dz = vtk_file.getReal();

    // Positionne les coordonn?es
    {
      Array<Real3> coords(nb_node);
      Real nz = Oz ;
      for( Integer z=0; z<nb_node_z; ++z )
        {
          Real ny = Oy ;
          for( Integer y=0; y<nb_node_y; ++y )
            {
              Real nx = Ox ;
              for( Integer x=0; x<nb_node_x; ++x )
                {
                  Integer node_unique_id = x + y*nb_node_x + z*nb_node_xy;
                  coords[node_unique_id] = Real3(nx,ny,nz);
                  nx += dx ;
                }
              ny += dy ;
            }
          nz += dz ;
        }
      VariableNodeReal3& nodes_coord_var(mesh->nodesCoordinates());
      ENUMERATE_NODE(inode,mesh->allNodes()){
        const Node& node = *inode;
        nodes_coord_var[inode] = coords[node.uniqueId()];
      }
    }
  }

  // Cr?? les groupes de faces des c?t?s du parall?l?pip?de
  {
    BufferT<Integer> xmin_node_lid;
    BufferT<Integer> xmax_node_lid;
    BufferT<Integer> ymin_node_lid;
    BufferT<Integer> ymax_node_lid;
    BufferT<Integer> zmin_node_lid;
    BufferT<Integer> zmax_node_lid;

    ENUMERATE_NODE(inode,mesh->allNodes()){
      const Node& node = *inode;
      Integer node_local_id = node.localId();
      bool is_xmin = true;
      bool is_xmax = true;
      bool is_ymin = true;
      bool is_ymax = true;
      bool is_zmin = true;
      bool is_zmax = true;
      Integer node_unique_id = node.uniqueId();
      Integer node_z = node_unique_id / nb_node_xy;
      Integer node_y = (node_unique_id - node_z*nb_node_xy) / nb_node_x;
      Integer node_x = node_unique_id - node_z*nb_node_xy - node_y*nb_node_x;
      if (node_x!=0)
        is_xmin = false;
      if (node_x!=(nb_node_x-1))
        is_xmax = false;
      if (node_y!=0)
        is_ymin = false;
      if (node_y!=(nb_node_y-1))
        is_ymax = false;
      if (node_z!=0)
        is_zmin = false;
      if (node_z!=(nb_node_z-1))
        is_zmax = false;
      
      if (is_xmin)
        xmin_node_lid.add(node_local_id);
      if (is_xmax)
        xmax_node_lid.add(node_local_id);
      if (is_ymin)
        ymin_node_lid.add(node_local_id);
      if (is_ymax)
        ymax_node_lid.add(node_local_id);
      if (is_zmin)
        zmin_node_lid.add(node_local_id);
      if (is_zmax)
        zmax_node_lid.add(node_local_id);
      
    }
    _createNodeGroup(mesh,"NodeXMIN",xmin_node_lid);
    _createNodeGroup(mesh,"NodeXMAX",xmax_node_lid);
    _createNodeGroup(mesh,"NodeYMIN",ymin_node_lid);
    _createNodeGroup(mesh,"NodeYMAX",ymax_node_lid);
    _createNodeGroup(mesh,"NodeZMIN",zmin_node_lid);
    _createNodeGroup(mesh,"NodeZMAX",zmax_node_lid);

  }
  _createGraphLinkType(    mesh,
                           use_internal_partition,
                           cells_local_id,
                           links_type) ;

  // Maintenant, regarde s'il existe des donn?es associ?es cell aux fichiers
  bool r = _readData(   mesh,
                        vtk_file,
                        use_internal_partition,
                        nodes_local_id,
                        cells_local_id);
  return r;
}


/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

bool IfpVtkMeshIOService::
_readStructuredDualGrid(IWritableMesh* mesh,IfpVtkFile& vtk_file,bool use_internal_partition)
{
  mesh::DynamicGraph* graph = dynamic_cast<mesh::DynamicGraph*> (mesh) ;
  if(graph==NULL)
    {
      error() << "le maillage doit etre de type DynamicGraph";
      return true ;
    }
  // IParallelMng* pm = subDomain()->parallelMng();
  
  // Lecture du nombre de points: DIMENSIONS nx ny nz
  const char* buf = 0;
  Integer nb_node_x = 0;
  Integer nb_node_y = 0;
  Integer nb_node_z = 0;
  {
    buf = vtk_file.getNextLine();
    istringstream iline(buf);
    std::string dimension_str;
    iline >> ws >> dimension_str >> ws >> nb_node_x
          >> ws >> nb_node_y >> ws >> nb_node_z;
    if (!iline){
      error() << "Erreur de syntaxe lors de la lecture des dimensions de la grille";
      return true;
    }
    vtk_file.checkString(dimension_str,"DIMENSIONS");
    if (nb_node_x<=1 || nb_node_y<=1 || nb_node_z<=1){
      error() << "Dimensions invalides: x=" << nb_node_x << " y=" << nb_node_y << " z=" << nb_node_z;
      return true;
    }
  }
  
  info() << " Infos: " << nb_node_x << " " << nb_node_y << " " << nb_node_z;
  Integer nb_node = nb_node_x * nb_node_y * nb_node_z;

  Real Ox = 0. ;
  Real Oy = 0. ;
  Real Oz = 0. ;
  Real dx = 0. ;
  Real dy = 0. ;
  Real dz = 0. ;
  // Lecture du nombre de points: POINTS nb float
  {
    buf = vtk_file.getNextLine();
    istringstream iline(buf);
    std::string origin_str;
    iline >> ws >> origin_str >> ws >> Ox >> ws >> Oy >> ws >> Oz;
    if (!iline){
      error() << "Erreur de syntaxe lors de la lecture des dimensions de la grille";
      return true;
    }
    vtk_file.checkString(origin_str,"ORIGIN");
  }
  {
    buf = vtk_file.getNextLine();
    istringstream iline(buf);
    std::string step_str;
    iline >> ws >> step_str >> ws >> dx >> ws >> dy >> ws >> dz;
    if (!iline){
      error() << "Erreur de syntaxe lors de la lecture des dimensions de la grille";
      return true;
    }
    vtk_file.checkString(step_str,"STEP");
  }

  Integer sub_domain_id = subDomain()->subDomainId();

  Integer nb_cell_x = nb_node_x-1;
  Integer nb_cell_y = nb_node_y-1;
  Integer nb_cell_z = nb_node_z-1;
  
  Integer nb_dnode_x = nb_cell_x ;
  Integer nb_dnode_y = nb_cell_y ;
  Integer nb_dnode_z = nb_cell_z ;
  Integer nb_link_x = nb_dnode_x -1 ;
  Integer nb_link_y = nb_dnode_y -1 ;
  Integer nb_link_z = nb_dnode_z -1 ;

  if (use_internal_partition && sub_domain_id!=0){
    nb_node_x = 0;
    nb_node_y = 0;
    nb_node_z = 0;
    nb_cell_x = 0;
    nb_cell_y = 0;
    nb_cell_z = 0;
    nb_dnode_x = 0;
    nb_dnode_y = 0;
    nb_dnode_z = 0;
    nb_link_x = 0;
    nb_link_y = 0;
    nb_link_z = 0;
  }
  
  Integer nb_node_yz = nb_node_y*nb_node_z;
  Integer nb_node_xy = nb_node_x*nb_node_y;

  Integer nb_cell = nb_cell_x * nb_cell_y * nb_cell_z;
  
  CArrayInteger cells_local_id(nb_cell);
  CArrayInteger nodes_local_id(nb_node);
  
  Integer nb_dnode_xz = nb_dnode_x*nb_dnode_z;
  Integer nb_dnode_yz = nb_dnode_y*nb_dnode_z;
  Integer nb_dnode_xy = nb_dnode_x*nb_dnode_y;

  Integer nb_dnode = nb_dnode_x * nb_dnode_y * nb_dnode_z;
  Integer nb_link = nb_link_x * nb_dnode_yz +
    nb_link_y * nb_dnode_xz +
    nb_link_z * nb_dnode_xy ;

  CArrayInteger links_local_id(nb_link);
  CArrayInteger links_type(nb_link);
  CArrayInteger dnodes_local_id(nb_dnode);

  // Creation du maillage et du graphe
  {
    CArrayInteger nodes_unique_id(nb_node);

    info() << " NODE YZ = " << nb_node_yz;
    // Cr?ation des noeuds
    Integer nb_node_local_id = 0;
    {
      Integer node_local_id = 0;
      for( Integer z=0; z<nb_node_z; ++z ){
        for( Integer y=0; y<nb_node_y; ++y ){
          for( Integer x=0; x<nb_node_x; ++x ){
    
            Integer node_unique_id = x + (y)*nb_node_x + z*nb_node_x*nb_node_y;
          
            nodes_unique_id[node_local_id] = node_unique_id;
            //Integer owner = sub_domain_id;
            //nodes_local_id[node_local_id] = node_local_id;
            
            ++node_local_id;
          }
        }
      }
      nb_node_local_id = node_local_id;
      warning() << " NB NODE LOCAL ID=" << node_local_id;
    }

    // Cr?ation des mailles
    
    // Infos pour la cr?ation des mailles
    // par maille: 1 pour son unique id,
    //             1 pour son type,
    //             8 pour chaque noeud
    CArrayInt64 cells_infos(nb_cell*10);

    {
      Integer cell_local_id = 0;
      Integer cells_infos_index = 0;

      for( Integer z=0; z<nb_cell_z; ++z ){
        for( Integer y=0; y<nb_cell_y; ++y ){
          for( Integer x=0; x<nb_cell_x; ++x ){
            Integer current_cell_nb_node = 8;
          
            //Integer cell_unique_id = y + (z)*nb_cell_y + x*nb_cell_y*nb_cell_z;
            Int64 cell_unique_id = x + y*nb_cell_x + z*nb_cell_x*nb_cell_y;
          
            cells_infos[cells_infos_index] = IT_Hexaedron8;
            ++cells_infos_index;

            cells_infos[cells_infos_index] = cell_unique_id;
            ++cells_infos_index;

            //Integer base_id = y + z*nb_node_y + x*nb_node_yz;
            Integer base_id = x + y*nb_node_x + z*nb_node_xy;
            cells_infos[cells_infos_index+0] = nodes_unique_id[base_id];
            cells_infos[cells_infos_index+1] = nodes_unique_id[base_id + 1];
            cells_infos[cells_infos_index+2] = nodes_unique_id[base_id + nb_node_x + 1];
            cells_infos[cells_infos_index+3] = nodes_unique_id[base_id + nb_node_x + 0];
            cells_infos[cells_infos_index+4] = nodes_unique_id[base_id + nb_node_xy];
            cells_infos[cells_infos_index+5] = nodes_unique_id[base_id + nb_node_xy + 1];
            cells_infos[cells_infos_index+6] = nodes_unique_id[base_id + nb_node_xy + nb_node_x + 1];
            cells_infos[cells_infos_index+7] = nodes_unique_id[base_id + nb_node_xy + nb_node_x + 0];
            cells_infos_index += current_cell_nb_node;
            cells_local_id[cell_local_id] = cell_local_id;
            ++cell_local_id;
          }
        }
      }
    }
  
  
  
    // Creation du graph
  
    CArrayInt64 dnodes_unique_id(nb_dnode);

    info() << " NODE YZ = " << nb_dnode_yz;
    // Cr?ation des noeuds
    Integer nb_dnode_local_id = 0;
    {
      Integer dnode_local_id = 0;
      for( Integer z=0; z<nb_dnode_z; ++z ){
        for( Integer y=0; y<nb_dnode_y; ++y ){
          for( Integer x=0; x<nb_dnode_x; ++x ){
    
            Integer dnode_unique_id = x + (y)*nb_dnode_x + z*nb_dnode_x*nb_dnode_y;
          
            dnodes_unique_id[dnode_local_id] = dnode_unique_id;
            
            dnodes_local_id[dnode_local_id] = dnode_local_id;
            
            ++dnode_local_id;
          }
        }
      }
      nb_dnode_local_id = dnode_local_id;
      warning() << " NB NODE LOCAL ID=" << dnode_local_id;
    }

    // Cr?ation des liaisons
    
    // Infos pour la cr?ation des liaisons
    // type de noeud dual : 1
    // par maille: 1 pour son unique id,
    //             1 pour son type,
    //             2 pour chaque noeud
    CArrayInt64 links_infos(nb_link*4+1) ;
    {
      Integer link_local_id = 0;
      Integer links_infos_index = 0;
      Integer current_link_nb_dnode = 2;
      links_infos[links_infos_index] = IT_DualCell ;
      ++links_infos_index;

      for( Integer z=0; z<nb_dnode_z; ++z ){
        for( Integer y=0; y<nb_dnode_y; ++y ){
          for( Integer x=0; x<nb_link_x; ++x ){
          
            //Integer cell_unique_id = y + (z)*nb_cell_y + x*nb_cell_y*nb_cell_z;
            Integer link_unique_id = x + y*nb_link_x + z*nb_link_x*nb_dnode_y ;
          
            links_infos[links_infos_index] = IT_Line2;
            ++links_infos_index;

            links_infos[links_infos_index] = link_unique_id;
            ++links_infos_index;

            //Integer base_id = y + z*nb_dnode_y + x*nb_dnode_yz;
            Integer base_id = x + y*nb_dnode_x + z*nb_dnode_xy;
            links_infos[links_infos_index+0] = dnodes_unique_id[base_id];
            links_infos[links_infos_index+1] = dnodes_unique_id[base_id + 1];
            links_infos_index += current_link_nb_dnode;
            links_local_id[link_local_id] = link_local_id;
            links_type[link_local_id] = 0 ;
            ++link_local_id;
          }
        }
      }
      Integer ptr_j = nb_link_x * nb_dnode_yz ;
      for( Integer z=0; z<nb_dnode_z; ++z ){
        for( Integer y=0; y<nb_link_y; ++y ){
          for( Integer x=0; x<nb_dnode_x; ++x ){
          
            //Integer link_unique_id = y + (z)*nb_link_y + x*nb_link_y*nb_link_z;
            Integer link_unique_id = ptr_j + x + y*nb_dnode_x + z*nb_dnode_x*nb_link_y;
          
            links_infos[links_infos_index] = IT_Line2;
            ++links_infos_index;

            links_infos[links_infos_index] = link_unique_id;
            ++links_infos_index;

            //Integer base_id = y + z*nb_dnode_y + x*nb_dnode_yz;
            Integer base_id = x + y*nb_dnode_x + z*nb_dnode_xy;
            links_infos[links_infos_index+0] = dnodes_unique_id[base_id];
            links_infos[links_infos_index+1] = dnodes_unique_id[base_id + nb_dnode_x + 0];
            links_infos_index += current_link_nb_dnode;
            links_local_id[link_local_id] = link_local_id;
            links_type[link_local_id] = 1 ;
            ++link_local_id;
          }
        }
      }
      Integer ptr_k = nb_link_x * nb_dnode_yz + nb_link_y*nb_dnode_xz ;
      for( Integer z=0; z<nb_link_z; ++z ){
        for( Integer y=0; y<nb_dnode_y; ++y ){
          for( Integer x=0; x<nb_dnode_x; ++x ){
          
            //Integer link_unique_id = y + (z)*nb_link_y + x*nb_link_y*nb_link_z;
            Integer link_unique_id = ptr_k + x + y*nb_dnode_x + z*nb_dnode_x*nb_dnode_y;
          
            links_infos[links_infos_index] = IT_Line2;
            ++links_infos_index;

            links_infos[links_infos_index] = link_unique_id;
            ++links_infos_index;

            //Integer base_id = y + z*nb_dnode_y + x*nb_dnode_yz;
            Integer base_id = x + y*nb_dnode_x + z*nb_dnode_xy;
            links_infos[links_infos_index+0] = dnodes_unique_id[base_id];
            links_infos[links_infos_index+1] = dnodes_unique_id[base_id + nb_dnode_xy];
            links_infos_index += current_link_nb_dnode;
            links_local_id[link_local_id] = link_local_id;
            links_type[link_local_id] = 2 ;
            ++link_local_id;
          }
        }
      }
    }
  
    graph->setDimension(3) ;
    graph->allocateCells(nb_cell,cells_infos,false);
    // cells_unique_id = dnodes_unique_id dans ce cas particulier
    graph->allocateLinks(nb_link,links_infos,false);
    graph->addDualNodes(IT_DualCell,nb_dnode,dnodes_unique_id,dnodes_unique_id) ;
    graph->endAllocate();
  
    // Positionne les coordonn?es
    {
      Array<Real3> coords(nb_node);
      Real nz = Oz ;
      for( Integer z=0; z<nb_node_z; ++z )
        {
          Real ny = Oy ;
          for( Integer y=0; y<nb_node_y; ++y )
            {
              Real nx = Ox ;
              for( Integer x=0; x<nb_node_x; ++x )
                {
                  Integer node_unique_id = x + y*nb_node_x + z*nb_node_xy;
                  coords[node_unique_id] = Real3(nx,ny,nz);
                  nx += dx ;
                }
              ny += dy ;
            }
          nz += dz ;
        }
      VariableNodeReal3& nodes_coord_var(mesh->nodesCoordinates());
      ENUMERATE_NODE(inode,mesh->allNodes()){
        const Node& node = *inode;
        nodes_coord_var[inode] = coords[node.uniqueId()];
      }
    }
  }

  // Cr?? les groupes de faces des c?t?s du parall?l?pip?de
  {
    BufferT<Integer> xmin_surface_lid;
    BufferT<Integer> xmax_surface_lid;
    BufferT<Integer> ymin_surface_lid;
    BufferT<Integer> ymax_surface_lid;
    BufferT<Integer> zmin_surface_lid;
    BufferT<Integer> zmax_surface_lid;

    ENUMERATE_FACE(iface,mesh->allFaces()){
      const Face& face = *iface;
      Integer face_local_id = face.localId();
      bool is_xmin = true;
      bool is_xmax = true;
      bool is_ymin = true;
      bool is_ymax = true;
      bool is_zmin = true;
      bool is_zmax = true;
      for( NodeEnumerator inode(face.nodes()); inode(); ++inode ){
        const Node& node = *inode;
        Int64 node_unique_id = node.uniqueId();
        Int64 node_z = node_unique_id / nb_node_xy;
        Int64 node_y = (node_unique_id - node_z*nb_node_xy) / nb_node_x;
        Int64 node_x = node_unique_id - node_z*nb_node_xy - node_y*nb_node_x;
        if (node_x!=0)
          is_xmin = false;
        if (node_x!=(nb_node_x-1))
          is_xmax = false;
        if (node_y!=0)
          is_ymin = false;
        if (node_y!=(nb_node_y-1))
          is_ymax = false;
        if (node_z!=0)
          is_zmin = false;
        if (node_z!=(nb_node_z-1))
          is_zmax = false;
      }
      if (is_xmin)
        xmin_surface_lid.add(face_local_id);
      if (is_xmax)
        xmax_surface_lid.add(face_local_id);
      if (is_ymin)
        ymin_surface_lid.add(face_local_id);
      if (is_ymax)
        ymax_surface_lid.add(face_local_id);
      if (is_zmin)
        zmin_surface_lid.add(face_local_id);
      if (is_zmax)
        zmax_surface_lid.add(face_local_id);
      
    }
    _createFaceGroup(mesh,"XMIN",xmin_surface_lid);
    _createFaceGroup(mesh,"XMAX",xmax_surface_lid);
    _createFaceGroup(mesh,"YMIN",ymin_surface_lid);
    _createFaceGroup(mesh,"YMAX",ymax_surface_lid);
    _createFaceGroup(mesh,"ZMIN",zmin_surface_lid);
    _createFaceGroup(mesh,"ZMAX",zmax_surface_lid);

  }

  // Maintenant, regarde s'il existe des donn?es associ?es cell aux fichiers
  bool r = _readData(   mesh,
                        vtk_file,
                        use_internal_partition,
                        nodes_local_id,
                        cells_local_id);
  if (r)
    return r;
  return false;
}



/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/*!
 * \brief Lecture des noeuds et de leur coordonn?es.
 */
void IfpVtkMeshIOService::
_readNodesUnstructuredGrid(IWritableMesh* mesh,IfpVtkFile& vtk_file,CArrayReal3& node_coords)
{
  const char* func_name = "IfpVtkMeshIOService::_readNodesUnstructuredGrid()";
  const char* buf = vtk_file.getNextLine();
  istringstream iline(buf);
  std::string points_str;
  std::string data_type_str;
  Integer nb_node = 0;
  iline >> ws >> points_str >> ws >> nb_node >> ws >> data_type_str;
  if (!iline)
    throw IOException(func_name,"Erreur de syntaxe lors de la lecture du nombre de points");
  vtk_file.checkString(points_str,"POINTS");
  vtk_file.checkString(data_type_str,"float","double");
  if (nb_node<0){
    String msg = "Nombre de noeuds invalide: n=" + nb_node;
    throw IOException(func_name,msg);
  }

  info() << " Infos: " << nb_node;

  // Lecture les coordonn?es
  node_coords.resize(nb_node);
  {
    for( Integer i=0; i<nb_node; ++i ){
      Real nx = vtk_file.getReal();
      Real ny = vtk_file.getReal();
      Real nz = vtk_file.getReal();
      node_coords[i] = Real3(nx,ny,nz);
    }
  }
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/*!
 * \brief Lecture des mailles et de leur connectivit?.
 *
 * En retour, remplit \a cells_nb_node, \a cells_type et \a cells_connectivity.
 */
void IfpVtkMeshIOService::
_readCellsUnstructuredGrid(IWritableMesh* mesh,IfpVtkFile& vtk_file,
                           CArrayInteger& cells_nb_node,
                           CArrayInteger& cells_type,
                           CArrayInt64& cells_connectivity)
{
  const char* func_name = "IfpVtkMeshIOService::_readCellsUnstructuredGrid()";
  const char* buf = vtk_file.getNextLine();
  istringstream iline(buf);
  std::string cells_str;
  Integer nb_cell = 0;
  Integer nb_cell_node = 0;
  iline >> ws >> cells_str >> ws >> nb_cell >> ws >> nb_cell_node;
  if (!iline)
    throw IOException(func_name,"Erreur de syntaxe lors de la lecture des mailles");
  vtk_file.checkString(cells_str,"CELLS");
  if (nb_cell<0 || nb_cell_node<0){
    String msg("Dimensions invalides: nb_cell=");
    msg += nb_cell;
    msg += " nb_cell_node=";
    msg += nb_cell_node;
    throw IOException(func_name,msg);
  }

  cells_nb_node.resize(nb_cell);
  cells_type.resize(nb_cell);
  cells_connectivity.resize(nb_cell_node);
  {
    Integer connectivity_index = 0;
    for( Integer i=0; i<nb_cell; ++i ){
      Integer n = vtk_file.getInteger();
      cells_nb_node[i] = n;
      for( Integer j=0; j<n; ++j ){
        Integer id = vtk_file.getInteger();
        cells_connectivity[connectivity_index] = id;
        ++connectivity_index;
      }
    }
  }

  // Lecture du type des mailles
  {
    buf = vtk_file.getNextLine();
    istringstream iline(buf);
    std::string cell_types_str;
    Integer nb_cell_type;
    iline >> ws >> cell_types_str >> ws >> nb_cell_type;
    if (!iline){
      throw IOException(func_name,"Erreur de syntaxe lors de la lecture du type des mailles");
    }
    vtk_file.checkString(cell_types_str,"CELL_TYPES");
    if (nb_cell_type!=nb_cell){
      String msg = "Incoherence dans le nomnbre CELL_TYPES: v=";
      msg += nb_cell_type;
      msg += " nb_cell=";
      msg += nb_cell;
      throw IOException(func_name,msg);
    }
  }
  for( Integer i=0; i<nb_cell; ++i ){
    Integer vtk_ct = vtk_file.getInteger();
    Integer it = IT_NullType;
    // Le type est d?fini dans vtkCellType.h
    switch(vtk_ct){
    case 0: it = IT_NullType; break; // VTK_EMPTY_CELL
    case 1: it = IT_Vertex; break; // VTK_VERTEX
    case 3: it = IT_Line2; break; // VTK_LINE
    case 5: it = IT_Triangle3; break; // VTK_TRIANGLE
    case 9: it = IT_Quad4; break; // VTK_QUAD
    case 7: // VTK_POLYGON (a tester...)
      if (cells_nb_node[i]==5)
        it = IT_Pentagon5;
      if (cells_nb_node[i]==6)
        it = IT_Hexagon6;
      break;
    case 10: it = IT_Tetraedron4; break; // VTK_TETRA
    case 14: it = IT_Pyramid5; break; // VTK_PYRAMID
    case 13: it = IT_Pentaedron6; break; // VTK_WEDGE
    case 12: it = IT_Hexaedron8; break; // VTK_HEXAHEDRON
    case 15: it = IT_Heptaedron10; break; // VTK_PENTAGONAL_PRISM
    case 16: it = IT_Octaedron12; break; // VTK_HEXAGONAL_PRISM
    default:
      {
        String msg = "Type de maille vtk inconnu ou invalid: type=" + vtk_ct;
        throw IOException(func_name,msg);
      }
      break;
    }
    cells_type[i] = it;
  }
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

bool IfpVtkMeshIOService::
_readUnstructuredGrid(IWritableMesh* mesh,IfpVtkFile& vtk_file,bool use_internal_partition)
{
  // const char* func_name = "IfpVtkMeshIOService::_readUnstructuredGrid()";
  // IParallelMng* pm = subDomain()->parallelMng();
  // ITraceMng* msg = subDomain()->traceMng();

  Integer nb_node = 0;
  Integer nb_cell = 0;
  Integer nb_cell_node = 0;
  Integer sid = subDomain()->subDomainId();
  CArrayReal3 node_coords;
  CArrayInt64 cells_infos;
  CArrayInteger cells_local_id;
  CArrayInteger nodes_local_id;
  // Si on utilise le partitionneur interne, seul le sous-domaine lit le maillage
  bool need_read = true;
  if (use_internal_partition)
    need_read = (sid==0);

  if (need_read){
    _readNodesUnstructuredGrid(mesh,vtk_file,node_coords);
    nb_node = node_coords.size();
    nodes_local_id.resize(nb_node);
    for(int inode=0;inode<nb_node;inode++)
      nodes_local_id[inode] = inode ;
    info()<<" nb_node"<<nb_node;

    // Lecture des infos des mailles
    // Lecture de la connectivit?
    CArrayT<Integer> cells_nb_node;
    CArrayT<Int64> cells_connectivity;
    CArrayT<Integer> cells_type;
    _readCellsUnstructuredGrid(mesh,vtk_file,cells_nb_node,cells_type,cells_connectivity);
    nb_cell = cells_nb_node.size();
    nb_cell_node = cells_connectivity.size();
    cells_local_id.resize(nb_cell);

    // Cr?ation des mailles
    // Infos pour la cr?ation des mailles
    // par maille: 1 pour son unique id,
    //             1 pour son type,
    //             1 pour chaque noeud
    cells_infos.resize(nb_cell*2 + nb_cell_node);
    {
      Integer cells_infos_index = 0;
      Integer connectivity_index = 0;
      for( Integer i=0; i<nb_cell; ++i ){
        Integer current_cell_nb_node = cells_nb_node[i];
        Integer cell_unique_id = i;
          
        cells_local_id[i] = i;

        cells_infos[cells_infos_index] = cells_type[i];
        ++cells_infos_index;

        cells_infos[cells_infos_index] = cell_unique_id;
        ++cells_infos_index;

        for( Integer z=0; z<current_cell_nb_node; ++z ){
          cells_infos[cells_infos_index+z] = cells_connectivity[connectivity_index+z];
        }
        cells_infos_index += current_cell_nb_node;
        connectivity_index += current_cell_nb_node;
      }
    }
  }

  mesh->setDimension(3);
  mesh->allocateCells(nb_cell,cells_infos,false);
  mesh->endAllocate();

  // Positionne les coordonn?es
  {
    VariableNodeReal3& nodes_coord_var(mesh->nodesCoordinates());
    ENUMERATE_NODE(inode,mesh->allNodes()){
      const Node& node = *inode;
      nodes_coord_var[inode] = node_coords[node.uniqueId().asInt64()];
    }
  }

  // Maintenant, regarde s'il existe des donn?es associ?es aux fichier
  bool r = _readData(   mesh,
                        vtk_file,
                        use_internal_partition,
                        nodes_local_id,
                        cells_local_id);
  return r;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void IfpVtkMeshIOService::
_readFacesMesh(IWritableMesh* mesh,const String& file_name,const String& dir_name,bool use_internal_partition)
{
  // const char* func_name = "IfpVtkMeshIOService::_readFacesMesh()";
  // ITraceMng* msg = subDomain()->traceMng();

  ifstream ifile(file_name.localstr());
  if (!ifile){
    info() << "Aucun fichier descriptif des faces '" << file_name << "'";
    return;
  }
  IfpVtkFile vtk_file(&ifile);
  const char* buf = 0;
  // Lecture de la description
  buf = vtk_file.getNextLine();
  String format = vtk_file.getNextLine();
  if (not IfpVtkFile::isEqualString(format,"ASCII")){
    error() << "Seul le format 'ASCII' est reconnu (format='" << format << "')";
    return;
  }
  eMeshType mesh_type = VTK_MT_Unknown;
  // Lecture du type de maillage
  // TODO: en parall?le, avec use_internal_partition vrai, seul le processeur 0
  // lit les donn?es. Dans ce cas, inutile que les autres ouvre le fichier.
  {
    buf = vtk_file.getNextLine();
    istringstream mesh_type_line(buf);
    std::string dataset_str;
    std::string mesh_type_str;
    mesh_type_line >> ws >> dataset_str >> ws >> mesh_type_str;
    vtk_file.checkString(dataset_str,"DATASET");
    if (IfpVtkFile::isEqualString(mesh_type_str,"UNSTRUCTURED_GRID")){
      mesh_type = VTK_MT_UnstructuredGrid;
    }
    if (mesh_type==VTK_MT_Unknown){
      error() << "Le fichier contenant les faces doit ?tre de type 'UNSTRUCTURED_GRID' (format=" << mesh_type_str << "')";
      return;
    }
  }
  {
    IParallelMng* pm = subDomain()->parallelMng();

    Integer nb_node = 0;
    Integer nb_face = 0;
    Integer nb_face_node = 0;
    Integer sid = pm->commRank() ;
  
    CArrayInteger faces_local_id;

    // Si on utilise le partitionneur interne, seul le sous-domaine lit le maillage
    bool need_read = true;
    if (use_internal_partition)
      need_read = (sid==0);

    if (need_read){
      {
        // Lit des noeuds, mais ne conserve pas leur coordonn?es
        CArrayReal3 node_coords;
        _readNodesUnstructuredGrid(mesh,vtk_file,node_coords);
        nb_node = node_coords.size();
      }

      // Lecture des infos des faces
      // Lecture de la connectivit?
      CArrayT<Integer> faces_nb_node;
      CArrayT<Int64> faces_connectivity;
      CArrayT<Integer> faces_type;
      _readCellsUnstructuredGrid(mesh,vtk_file,faces_nb_node,faces_type,faces_connectivity);
      nb_face = faces_nb_node.size();
      nb_face_node = faces_connectivity.size();
      
      // Il faut ? partir de la connectivit? retrouver les localId() des faces
      faces_local_id.resize(nb_face);
      {
        IMeshUtilities* mu = mesh->utilities();
        mu->localIdsFromConnectivity(IK_Face,faces_nb_node,faces_connectivity,faces_local_id);
      }
    }
    

    // Maintenant, regarde s'il existe des donn?es associ?es aux fichier
    _readFaceData(mesh,vtk_file,use_internal_partition,IK_Face,faces_local_id);
  }
}

bool IfpVtkMeshIOService::
check(Integer i, Integer j, Integer k, Integer nx, Integer ny, Integer nz)
{
  if(i<0||i>nx) 
  {
    error()<<"i:"<<i<<"out of range";
    return true ;
  }
  if(j<0||j>ny)
  {
    error()<<"j:"<<i<<"out of range";
    return true ;
  }
  if(k<0||k>nz)
  {
    error()<<"k:"<<i<<"out of range";
    return true ;
  }
  return false ;
}

void IfpVtkMeshIOService::
_readStructuredFacesMesh(IWritableMesh* mesh,const String& file_name,const String& dir_name,bool use_internal_partition)
{
  // const char* func_name = "IfpVtkMeshIOService::_readFacesMesh()";
  // ITraceMng* msg = subDomain()->traceMng();

  IParallelMng* pm = subDomain()->parallelMng();
  Integer sid = pm->commRank() ; 
  // Si on utilise le partitionneur interne, seul le sous-domaine lit le maillage
  bool need_read = true;
  if (use_internal_partition)
    need_read = (sid==0);

  ifstream ifile(file_name.localstr());
  if (!ifile){
    info() << "Aucun fichier descriptif des faces '" << file_name << "'";
    return;
  }
  IfpVtkFile vtk_file(&ifile);
  const char* buf = 0;
  Integer nb_node_x = 0;
  Integer nb_node_y = 0;
  Integer nb_node_z = 0;
  Integer nb_face = 0 ;
  Integer nb_face_node = 0 ;
  if(sid==0) 
  {
    {
      buf = vtk_file.getNextLine();
      istringstream iline(buf);
      std::string dimension_str;
      iline >> ws >> dimension_str >> ws >> nb_node_x
            >> ws >> nb_node_y >> ws >> nb_node_z;
      if (!iline){
        error() << "Erreur de syntaxe lors de la lecture des dimensions de la grille";
        return ;
      }
      vtk_file.checkString(dimension_str,"DIMENSIONS");
      if (nb_node_x<0 || nb_node_y<0 || nb_node_z<0 || nb_node_x+nb_node_y+nb_node_z<1){
        error() << "Dimensions invalides: x=" << nb_node_x << " y=" << nb_node_y << " z=" << nb_node_z;
        return ;
      }
    }
    {
      buf = vtk_file.getNextLine();
      istringstream iline(buf);
      std::string faces_str;
      iline >> ws >> faces_str >> ws >> nb_face;
      vtk_file.checkString(faces_str,"FACES");
      if (nb_face<0){
        error() << "Dimensions invalides: numbre de face=" << nb_face;
        return ;
      }
    }
  
    info() << " Infos: " << nb_node_x << " " << nb_node_y << " " << nb_node_z;
    info() << " Nombre de faces: " << nb_face;
    //nb_node = nb_node_x * nb_node_y * nb_node_z;
  
    // Integer sub_domain_id = subDomain()->subDomainId();
  
    // Integer nb_cell_x = nb_node_x-1;
    // Integer nb_cell_y = nb_node_y-1;
    // Integer nb_cell_z = nb_node_z-1;
  
    // Integer nb_node_yz = nb_node_y*nb_node_z;
    // Integer nb_node_xy = nb_node_x*nb_node_y;
  
    //nb_cell = nb_cell_x * nb_cell_y * nb_cell_z;
  }
  CArrayInteger faces_local_id(nb_face);
  if(sid==0)
  {
    // Lecture des infos des faces
    // Lecture de la connectivit?
    CArrayT<Integer> faces_nb_node;
    CArrayT<Int64> faces_connectivity;
    CArrayT<Integer> faces_type;
    nb_face_node=4*nb_face ;
    faces_nb_node.resize(nb_face);
    faces_type.resize(nb_face);
    faces_connectivity.resize(nb_face_node);
    {
      Integer connectivity_index = 0;
      for( Integer iface=0; iface<nb_face; ++iface )
      {
        Integer i = vtk_file.getInteger();
        Integer j = vtk_file.getInteger();
        Integer k = vtk_file.getInteger();
        Integer l = vtk_file.getInteger();
        if(l<0||l>2) error()<<"l:"<<l<<"out of range";
        faces_nb_node[iface] = 4;
        if(l==0)
          {
            if(check(i,j,k,nb_node_x,nb_node_y,nb_node_z)) return ;
            faces_connectivity[connectivity_index] = k*(nb_node_x*nb_node_y)+j*nb_node_x+i;
            i++ ;
            ++connectivity_index;
            if(check(i,j,k,nb_node_x,nb_node_y,nb_node_z)) return ;
            faces_connectivity[connectivity_index] = k*(nb_node_x*nb_node_y)+j*nb_node_x+i;
            j++ ;
            ++connectivity_index;
            if(check(i,j,k,nb_node_x,nb_node_y,nb_node_z)) return ;
            faces_connectivity[connectivity_index] = k*(nb_node_x*nb_node_y)+j*nb_node_x+i;
            i--;
            ++connectivity_index;
            if(check(i,j,k,nb_node_x,nb_node_y,nb_node_z)) return ;
            faces_connectivity[connectivity_index] = k*(nb_node_x*nb_node_y)+j*nb_node_x+i;
            ++connectivity_index;
          }
        if(l==1)
          {
            if(check(i,j,k,nb_node_x,nb_node_y,nb_node_z)) return ;
            faces_connectivity[connectivity_index] = k*(nb_node_x*nb_node_y)+j*nb_node_x+i;
            i++ ;
            ++connectivity_index;
            if(check(i,j,k,nb_node_x,nb_node_y,nb_node_z)) return ;
            faces_connectivity[connectivity_index] = k*(nb_node_x*nb_node_y)+j*nb_node_x+i;
            k++ ;
            ++connectivity_index;
            if(check(i,j,k,nb_node_x,nb_node_y,nb_node_z)) return ;
            faces_connectivity[connectivity_index] = k*(nb_node_x*nb_node_y)+j*nb_node_x+i;
            i--;
            ++connectivity_index;
            if(check(i,j,k,nb_node_x,nb_node_y,nb_node_z)) return ;
            faces_connectivity[connectivity_index] = k*(nb_node_x*nb_node_y)+j*nb_node_x+i;
            ++connectivity_index;
          }
        if(l==2)
          {
            if(check(i,j,k,nb_node_x,nb_node_y,nb_node_z)) return ;
            faces_connectivity[connectivity_index] = k*(nb_node_x*nb_node_y)+j*nb_node_x+i;
            j++ ;
            ++connectivity_index;
            if(check(i,j,k,nb_node_x,nb_node_y,nb_node_z)) return ;
            faces_connectivity[connectivity_index] = k*(nb_node_x*nb_node_y)+j*nb_node_x+i;
            k++ ;
            ++connectivity_index;
            if(check(i,j,k,nb_node_x,nb_node_y,nb_node_z)) return ;
            faces_connectivity[connectivity_index] = k*(nb_node_x*nb_node_y)+j*nb_node_x+i;
            j--;
            ++connectivity_index;
            if(check(i,j,k,nb_node_x,nb_node_y,nb_node_z)) return ;
            faces_connectivity[connectivity_index] = k*(nb_node_x*nb_node_y)+j*nb_node_x+i;
            ++connectivity_index;
          }
        faces_type[iface] = IT_Quad4 ;
      }
    }
    
    // Il faut ? partir de la connectivit? retrouver les localId() des faces
    //faces_local_id.resize(nb_face);
    {
      IMeshUtilities* mu = mesh->utilities();
      mu->localIdsFromConnectivity(IK_Face,faces_nb_node,faces_connectivity,faces_local_id);
    }
  }
    
  // Maintenant, regarde s'il existe des donn?es associ?es aux fichier
  _readFaceData(mesh,vtk_file,use_internal_partition,IK_Face,faces_local_id);
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

bool IfpVtkMeshIOService::_readData( IWritableMesh* mesh,
                                     IfpVtkFile& vtk_file,
                                     bool use_internal_partition,
                                     CArrayInteger& node_local_ids,
                                     CArrayInteger& cell_local_ids,
                                     const char * buf)
{
  // Seul le sous-domain maitre lit les valeurs. Par contre, les autres
  // sous-domaines doivent connaitre la liste des variables et groupes cr??es.
  // Si une donn?e porte le nom 'GROUP_*', on consid?re qu'il s'agit d'un
  // groupe
  info()<<"READATA :****************************";
  OCStringStream created_infos_str;
  created_infos_str() << "<?xml version='1.0' ?>\n";
  created_infos_str() << "<infos>";
  Integer sid = subDomain()->subDomainId();
  IParallelMng* pm = subDomain()->parallelMng();
  Integer nb_node_kind = mesh->nbItem(IK_Node);
  Integer nb_cell_kind = mesh->nbItem(IK_Cell);
  
  bool reading_node = false;
  bool reading_cell = false;
  eItemKind item_kind ;
  if (sid==0){
    bool continue_loop = ((buf!=NULL) or ( !vtk_file.isEnd() && (buf=vtk_file.getNextLine())!=0));
    while(continue_loop) {
      info() << "Read line";
      istringstream iline(buf);
      std::string data_str;
      iline >> data_str;
      if (IfpVtkFile::isEqualString(data_str,"POINT_DATA")){
        Integer nb_item =0;
        iline >> ws >> nb_item;
        reading_node = true;
        reading_cell = false;
        item_kind = IK_Node ;
      }
      else if (IfpVtkFile::isEqualString(data_str,"CELL_DATA")){
        Integer nb_item =0;
        iline >> ws >> nb_item;
        reading_cell = true;
        reading_node = false;
        item_kind = IK_Cell ;
      }
      else if (reading_node){
        if(_readNodeData(   mesh,
                            vtk_file,
                            nb_node_kind,
                            node_local_ids,
                            buf,
                            iline,
                            data_str,
                            created_infos_str)) 
          return true ;
      }
      else if(reading_cell){
        if(_readCellData(   mesh,
                            vtk_file,
                            nb_cell_kind,
                            cell_local_ids,
                            buf,
                            iline,
                            data_str,
                            created_infos_str))
          return true ;
      }
      else {
        error() << "Attend valeur POINT_DATA ou CELL_DATA, lu='" << data_str << "'";
        return true;
      }
      continue_loop = ( !vtk_file.isEnd() && (buf=vtk_file.getNextLine())!=0);
    }
  }

  created_infos_str() << "</infos>";
  if (use_internal_partition){
    ByteArray bytes;
    if (sid==0){
      info()<<"READATA :**********PROC MASTER";
      ConstCString str = created_infos_str.str();
      Integer len = str.len();
      bytes.resize(len+1);
      ::memcpy(bytes.begin(),str.str(),len+1);
      info() << "SEND STR=" << str;
    }
    pm->broadcastMemoryBuffer(bytes,0);
    if (sid!=0){
      CString str((char*)bytes.begin(),bytes.size());
      info() << "FOUND STR=" << bytes.size() << " " << str;
      IIOMng* iomng = subDomain()->ioMng();
      IXmlDocumentHolder* doc = iomng->parseXmlBuffer(bytes,"InternalBuffer");
      XmlNode doc_node = doc->documentNode();
      // Lecture des variables
      {
        XmlNodeList vars = doc_node.documentElement().children("node-variable");
        for( XmlNodeList::const_iter i(vars); i(); ++i ){
          XmlNode xnode = *i;
          String name = xnode.attrValue("name");
          info() << "Cr?ation variable: " << name;
          VariableNodeReal var(VariableBuildInfo(mesh,name));
        }
      }
      // Lecture des groupes
      {
        XmlNodeList vars = doc_node.documentElement().children("node-group");
        IItemFamily* node_family = mesh->itemFamily(IK_Node);
        for( XmlNodeList::const_iter i(vars); i(); ++i ){
          XmlNode xnode = *i;
          String name = xnode.attrValue("name");
          info() << "Cr?ation group: " << name;
          node_family->createGroup(name);
        }
      }
      // Lecture des variables
      {
        XmlNodeList vars = doc_node.documentElement().children("cell-variable");
        for( XmlNodeList::const_iter i(vars); i(); ++i ){
          XmlNode xnode = *i;
          String name = xnode.attrValue("name");
          info() << "Cr?ation variable: " << name;
          VariableNodeReal var(VariableBuildInfo(mesh,name));
        }
      }
      // Lecture des groupes
      {
        XmlNodeList vars = doc_node.documentElement().children("cell-group");
        IItemFamily* cell_family = mesh->itemFamily(IK_Cell);
        for( XmlNodeList::const_iter i(vars); i(); ++i ){
          XmlNode xnode = *i;
          String name = xnode.attrValue("name");
          info() << "Cr?ation group: " << name;
          cell_family->createGroup(name);
        }
      }
    }
  }
  return false;
}

bool IfpVtkMeshIOService::_readNodeData( IWritableMesh* mesh,
                                         IfpVtkFile& vtk_file,
                                         int nb_node_kind,
                                         CArrayInteger& local_ids,
                                         const char* buf,
                                         istringstream& iline,             
                                         std::string& data_str,
                                         OCStringStream& created_infos_str)
{
  std::string type_str;
  std::string name_str;
  bool is_group = false;
  int nb_component = 0;
  iline >> ws >> name_str >> ws >> type_str >> ws >> nb_component;
  info() << "** ** ** READNAME: name=" << name_str << " type=" << type_str;
  CString cstr(name_str.c_str());
  if (cstr.left(6)=="GROUP_"){
    is_group = true;
    std::string new_name(name_str.c_str()+6);
    info() << "** ** ** GROUP ! name=" << new_name;
    name_str = new_name;
  }
  if (not IfpVtkFile::isEqualString(data_str,"SCALARS")){
    error() << "Seules les donn?es 'SCALARS' sont support?es, lu=" << data_str;
    return true;
  }
  if (is_group)
    {
      if (not IfpVtkFile::isEqualString(type_str,"int"))
        {
          error() << "Le type pour les groupes doit ?tre 'int', lu=" << type_str;
          return true;
        }
      // Pour lire LOOKUP_TABLE
      buf = vtk_file.getNextLine();
      created_infos_str() << "<node-group name='" << name_str << "'/>";
      _readItemGroup(mesh,vtk_file,name_str,nb_node_kind,IK_Node,local_ids);
    }
  else
    {
      if (not IfpVtkFile::isEqualString(type_str,"float") and not IfpVtkFile::isEqualString(type_str,"double"))
        {
          error() << "Seules les donn?es de type 'float' ou 'double' sont support?es, lu=" << type_str;
          return true;
        }
      // Pour lire LOOKUP_TABLE
      buf = vtk_file.getNextLine();
      created_infos_str() << "<node-variable name='" << name_str << "'/>";
      _readNodeVariable(mesh,vtk_file,name_str,nb_node_kind);
    }
  return false ;
}




bool IfpVtkMeshIOService::_readCellData(IWritableMesh* mesh,
                                        IfpVtkFile& vtk_file, 
                                        int nb_cell_kind,
                                        CArrayInteger& local_ids,
                                        const char* buf,
                                        istringstream& iline,           
                                        std::string& data_str,
                                        OCStringStream& created_infos_str)
{
  // Seul le sous-domain maitre lit les valeurs. Par contre, les autres
  // sous-domaines doivent connaitre la liste des variables et groupes cr??es.
  // Si une donn?e porte le nom 'GROUP_*', on consid?re qu'il s'agit d'un
  // groupe

    
  std::string type_str;
  std::string name_str;
  bool is_group = false;
  int nb_component = 0;
  iline >> ws >> name_str >> ws >> type_str >> ws >> nb_component;
  info() << "** ** ** READNAME: name=" << name_str << " type=" << type_str;
  CString cstr(name_str.c_str());
  if (cstr.left(6)=="GROUP_"){
    is_group = true;
    std::string new_name(name_str.c_str()+6);
    info() << "** ** ** GROUP ! name=" << new_name;
    name_str = new_name;
  }
  if (not IfpVtkFile::isEqualString(data_str,"SCALARS")){
    error() << "Seules les donn?es 'SCALARS' sont support?es, lu=" << data_str;
    return true;
  }
  if (is_group){
    if (not IfpVtkFile::isEqualString(type_str,"int")){
      error() << "Le type pour les groupes doit ?tre 'int', lu=" << type_str;
      return true;
    }
    // Pour lire LOOKUP_TABLE
    buf = vtk_file.getNextLine();
    created_infos_str() << "<cell-group name='" << name_str << "'/>";
    _readItemGroup(mesh,vtk_file,name_str,nb_cell_kind,IK_Cell,local_ids); 
  }
  else
    {
      if (not IfpVtkFile::isEqualString(type_str,"float") and not IfpVtkFile::isEqualString(type_str,"double")){
        error() << "Seules les donn?es de type 'float' ou 'double' sont support?es, lu=" << type_str;
        return true;
      }
      // Pour lire LOOKUP_TABLE
      buf = vtk_file.getNextLine();
      created_infos_str() << "<cell-variable name='" << name_str << "'/>";
      _readCellVariable(mesh,vtk_file,name_str,nb_cell_kind);
    }
  return false ;
}

  


bool IfpVtkMeshIOService::
_readFaceData(IWritableMesh* mesh,
              IfpVtkFile& vtk_file,
              bool use_internal_partition,
              eItemKind item_kind,
              ConstCArrayInteger local_ids)
{
  // Seul le sous-domain maitre lit les valeurs. Par contre, les autres
  // sous-domaines doivent connaitre la liste des variables et groupes cr??es.
  // Si une donn?e porte le nom 'GROUP_*', on consid?re qu'il s'agit d'un
  // groupe

  OCStringStream created_infos_str;
  created_infos_str() << "<?xml version='1.0' ?>\n";
  created_infos_str() << "<infos>";
  Integer sid = subDomain()->subDomainId();
  IParallelMng* pm = subDomain()->parallelMng();
  Integer nb_item_kind = mesh->nbItem(item_kind);
  Integer nb_faces = 0 ;
  
  const char* buf = 0;
  bool reading_cell = false;
  if (sid==0){
    while ( !vtk_file.isEnd() && ((buf = vtk_file.getNextLine()) != 0)){
      info() << "Read line";
      istringstream iline(buf);
      std::string data_str;
      iline >> data_str;
      if (IfpVtkFile::isEqualString(data_str,"CELL_DATA")){
        Integer nb_item =0;
        iline >> ws >> nb_item;
        reading_cell = true;
        nb_faces = nb_item ;
      }
      else{
        if (reading_cell){
          std::string type_str;
          std::string name_str;
          bool is_group = false;
          int nb_component = 0;
          iline >> ws >> name_str >> ws >> type_str >> ws >> nb_component;
          info() << "** ** ** READNAME: name=" << name_str << " type=" << type_str;
          CString cstr(name_str.c_str());
          if (cstr.left(6)=="GROUP_"){
            is_group = true;
            std::string new_name(name_str.c_str()+6);
            info() << "** ** ** GROUP ! name=" << new_name;
            name_str = new_name;
          }
          if (not IfpVtkFile::isEqualString(data_str,"SCALARS")){
            error() << "Seules les donn?es 'SCALARS' sont support?es, lu=" << data_str;
            return true;
          }
          if (is_group){
            if (not IfpVtkFile::isEqualString(type_str,"int")){
              error() << "Le type pour les groupes doit ?tre 'int', lu=" << type_str;
              return true;
            }
            // Pour lire LOOKUP_TABLE
            buf = vtk_file.getNextLine();
            if (reading_cell){
              created_infos_str() << "<cell-group name='" << name_str << "'/>";
              _readItemGroup(mesh,vtk_file,name_str,nb_faces,item_kind,local_ids);
            }
          }
          else{
            if (not IfpVtkFile::isEqualString(type_str,"float") and not IfpVtkFile::isEqualString(type_str,"double")){
              error() << "Seules les donn?es de type 'float' ou 'double' sont support?es, lu=" << type_str;
              return true;
            }
            // Pour lire LOOKUP_TABLE
            buf = vtk_file.getNextLine();
            if (reading_cell){
              created_infos_str() << "<cell-variable name='" << name_str << "'/>";
              if (item_kind!=IK_Cell)
                throw IOException("Lecture des variables aux faces non support?e");
              _readCellVariable(mesh,vtk_file,name_str,nb_item_kind);
            }
          }
        }
        else{
          error() << "Attend valeur CELL_DATA ou POINT_DATA, lu='" << data_str << "'";
          return true;
        }
      }
    }
  }
  created_infos_str() << "</infos>";
  if (use_internal_partition){
    ByteArray bytes;
    if (sid==0){
      ConstCString str = created_infos_str.str();
      Integer len = str.len();
      bytes.resize(len+1);
      ::memcpy(bytes.begin(),str.str(),len+1);
      info() << "SEND STR=" << str;
    }
    pm->broadcastMemoryBuffer(bytes,0);
    if (sid!=0){
      CString str((const char*)bytes.begin(),bytes.size());
      info() << "FOUND STR=" << bytes.size() << " " << str;
      IIOMng* iomng = subDomain()->ioMng();
      IXmlDocumentHolder* doc = iomng->parseXmlBuffer(bytes,"InternalBuffer");
      XmlNode doc_node = doc->documentNode();
      // Lecture des variables
      {
        XmlNodeList vars = doc_node.documentElement().children("cell-variable");
        for( XmlNodeList::const_iter i(vars); i(); ++i ){
          XmlNode xnode = *i;
          String name = xnode.attrValue("name");
          info() << "Cr?ation variable: " << name;
          VariableCellReal var(VariableBuildInfo(mesh,name));
        }
      }
      // Lecture des groupes
      {
        XmlNodeList vars = doc_node.documentElement().children("cell-group");
        IItemFamily* item_family = mesh->itemFamily(item_kind);
        for( XmlNodeList::const_iter i(vars); i(); ++i ){
          XmlNode xnode = *i;
          String name = xnode.attrValue("name");
          info() << "Cr?ation group: " << name;
          item_family->createGroup(name);
        }
      }
    }
  }
  return false;
}

bool IfpVtkMeshIOService::_createGraphLinkType(    IWritableMesh* mesh,
                                                   bool use_internal_partition,
                                                   CArrayInteger& cell_local_ids,
                                                   CArrayInteger& links_type)
{
  // Seul le sous-domain maitre lit les valeurs. Par contre, les autres
  // sous-domaines doivent connaitre la liste des variables et groupes cr??es.

  //OCStringStream created_infos_str;
  //created_infos_str() << "<?xml version='1.0' ?>\n";
  //created_infos_str() << "<infos>";
  Integer sid = subDomain()->subDomainId();
  // IParallelMng* pm = subDomain()->parallelMng();
  Integer nb_cell_kind = mesh->nbItem(IK_Cell);
  std::string name_str("CellVtkType");
  info() << "Lecture valeurs pour la variable: " << name_str << " n=" << nb_cell_kind;
  VariableCellReal var(VariableBuildInfo(mesh,name_str));
  if (sid==0)
    {
      RealArrayView values(var.variable()->accessor()->asArrayReal());
      for( Integer i=0; i<nb_cell_kind; ++i )
        {
          values[i] = links_type[i];
        }
    }
  info() << "Fin cr?ation de la variable: " ;
  
  /*
    eItemKind item_kind ;
    if (sid==0){
    item_kind = IK_Cell ;
    
    std::string type_str;
    std::string name_str("CellVtkType");
    created_infos_str() << "<cell-variable name='" << name_str << "'/>";
    
    info() << "Lecture valeurs pour la variable: " << name_str << " n=" << nb_cell_kind;
    VariableCellReal var(VariableBuildInfo(mesh,name_str));
    CArrayBaseReal values(var.variable()->accessor()->asArrayReal());
    for( Integer i=0; i<nb_cell_kind; ++i ){
    values[i] = links_type[i];
    }
    info() << "Fin cr?ation de la variable: " ;
    }
    created_infos_str() << "</infos>";
    if (use_internal_partition){
    CArrayByte bytes;
    if (sid==0){
    ConstCString str = created_infos_str.str();
    Integer len = str.len();
    bytes.resize(len+1);
    ::memcpy(bytes.begin(),str.str(),len+1);
    info() << "SEND STR=" << str;
    }
    pm->broadcastMemoryBuffer(bytes,0);
    if (sid!=0){
    CString str(bytes.begin(),bytes.size());
    info() << "FOUND STR=" << bytes.size() << " " << str;
    IIOMng* iomng = subDomain()->ioMng();
    IXmlDocumentHolder* doc = iomng->parseXmlBuffer(bytes,"InternalBuffer");
    XmlNode doc_node = doc->documentNode();
    // Lecture des variables
    {
    XmlNodeList vars = doc_node.documentElement().children("cell-variable");
    for( XmlNodeList::const_iter i(vars); i(); ++i ){
    XmlNode xnode = *i;
    String name = xnode.attrValue("name");
    info() << "Cr?ation variable: " << name;
    VariableNodeReal var(VariableBuildInfo(mesh,name));
    }
    }
    }
    }
  */
  return false;
}


/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void IfpVtkMeshIOService::
_createFaceGroup(IMesh* mesh,const String& name,ConstCArrayInteger faces_lid)
{
  info() << "Creation group de face '" << name << "'"
         << " taille = " << faces_lid.size();

  mesh->faceFamily()->createGroup(name,faces_lid);
}

void IfpVtkMeshIOService::
_createNodeGroup(IMesh* mesh,const String& name,ConstCArrayInteger nodes_lid)
{
  info() << "Creation group de node '" << name << "'"
         << " taille = " << nodes_lid.size();

  mesh->nodeFamily()->createGroup(name,nodes_lid);
}


/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void IfpVtkMeshIOService::
_readNodeVariable(IWritableMesh* mesh,IfpVtkFile& vtk_file,const String& var_name,Integer nb_node)
{
  //TODO Faire la conversion uniqueId() vers localId() correcte
  info() << "Lecture valeurs pour la variable: " << var_name << " n=" << nb_node;
  VariableNodeReal * var_node = new VariableNodeReal(VariableBuildInfo(mesh,var_name));
   
  variable_node_real.add( var_node );

  RealArrayView  values(var_node->variable()->accessor()->asArrayReal());

  for( Integer i=0; i<nb_node; ++i ){
    Real v = vtk_file.getReal();
    values[i] = v;
  }
  info() << "Fin cr?ation de la variable: " << vtk_file.isEnd();
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void IfpVtkMeshIOService::
_readCellVariable(IWritableMesh* mesh,
                  IfpVtkFile& vtk_file,
                  const String& var_name,
                  Integer nb_cell)
{
  //TODO Faire la conversion uniqueId() vers localId() correcte
  info() << "Lecture valeurs pour la variable: " << var_name << " n=" << nb_cell;
  
  VariableCellReal * var_cell = new VariableCellReal(VariableBuildInfo(mesh,var_name));
  variable_cell_real.add( var_cell );
  
  RealArrayView  values(var_cell->variable()->accessor()->asArrayReal());


  for( Integer i=0; i<nb_cell; ++i ){
    Real v = vtk_file.getReal();
    values[i] = v;
  }
  info() << "Fin cr?ation de la variable: " << var_cell->variable()->fullName() << " " << vtk_file.isEnd();
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void IfpVtkMeshIOService::
_readItemGroup(IWritableMesh* mesh,IfpVtkFile& vtk_file,const String& name,Integer nb_item,
               eItemKind ik,ConstCArrayInteger local_ids)
{
  IItemFamily* item_family = mesh->itemFamily(ik);
  info() << "Lecture infos groupes pour le groupe: " << name;
  
  BufferT<Integer> ids;
  for( Integer i=0; i<nb_item; ++i ){
    Integer v = vtk_file.getInteger();
    if (v!=0)
      ids.add(local_ids[i]);
  }
  info() << "Cr?ation groupe: " << name << " nb_element=" << ids.size();

  item_family->createGroup(name,ids);
}

void IfpVtkMeshIOService::
_createItemGroup(IMesh* mesh,
                 IfpVtkFile& vtk_file,
                 const char* buf,
                 Integer nb_item_x,
                 Integer nb_item_y,
                 Integer nb_item_z,
                 Integer first_x,
                 Integer local_nb_item_x,
                 Integer first_y,
                 Integer local_nb_item_y,
                 eItemKind ik,
                 bool use_internal_partition)
{
  Integer i1,i2,j1,j2,k1,k2;
  std::string group_name ;
  buf = vtk_file.getNextLine() ;
  istringstream iline(buf) ;
  iline >> ws >> group_name 
        >> ws >> i1 >> ws >> i2
        >> ws >> j1 >> ws >> j2
        >> ws >> k1 >> ws >> k2 ;
  BufferT<Int64> uids;
  Integer nb_item = 0 ;
  if((subDomain()->subDomainId()==0)||(!use_internal_partition))
  {
    // Integer nb_item_xy = nb_item_x*nb_item_y ;
    // Integer local_nb_item_xy = local_nb_item_x*local_nb_item_y ;
    uids.reserve((i2+1-i1)*(j2+1-j1)*(k2+1-k1)) ;
    for(Integer k=k1-1;k<k2;k++)
      for(Integer j=j1-1;j<j2;j++)
        if((j>=first_y)&&(j<first_y+local_nb_item_y))
          for(Integer i=i1-1;i<i2;i++)
             if((i>=first_x)&&(i<first_x+local_nb_item_x))
             {
               Int64 uid = k*nb_item_x*nb_item_y+j*nb_item_x+i ;
               uids.add(uid) ;
               nb_item++ ;
             }
  }
  IItemFamily* item_family = mesh->itemFamily(ik);
  CArrayT<Integer> ids(nb_item) ;
  item_family->itemsUniqueIdToLocalId(ids,uids) ;
  info() << "Creation groupe: " << group_name << " nb_element=" << ids.size();
  item_family->createGroup(group_name,ids);
}

void IfpVtkMeshIOService::
_computePartition(Integer nproc,Integer* np1, Integer* np2)
{
  switch(nproc)
  {
  case 4 :
    *np1 = 2 ;
    *np2 = 2 ;
    break ;
  case 6 :
    *np1 = 2 ;
    *np2 = 3 ;
    break ;
  case 8 :
    *np1 = 2 ;
    *np2 = 4 ;
    break ;
  case 9 :
    *np1 = 3 ;
    *np2 = 3 ;
    break ;
  case 10 :
    *np1 = 2 ;
    *np2 = 5 ;
    break ;
  case 12 :
    *np1 = 3 ;
    *np2 = 4 ;
    break ;
  case 14 :
    *np1 = 2 ;
    *np2 = 7 ;
    break ;
  case 15 :
    *np1 = 3 ;
    *np2 = 5 ;
    break ;
  case 16 :
    *np1 = 4 ;
    *np2 = 4 ;
    break ;
  case 18 :
    *np1 = 3 ;
    *np2 = 6 ;
    break ;
  case 20 :
    *np1 = 4 ;
    *np2 = 5 ;
    break ;
  case 32 :
    *np1 = 4 ;
    *np2 = 8 ;
    break ;
  case 64 :
    *np1 = 8 ;
    *np2 = 8 ;
    break ;
  case 128 :
    *np1 = 8 ;
    *np2 = 16 ;
    break ;
  case 256 :
    *np1 = 16 ;
    *np2 = 16 ;
    break ;
  }
}

bool IfpVtkMeshIOService::
_readDistStructuredGrid(IWritableMesh* mesh,IfpVtkFile& vtk_file,bool use_internal_partition)
{
  IParallelMng* pm = subDomain()->parallelMng();

  ////////////////////////////////////////////////////////////
  // Lecture des paramètres obligatoires

  // Lecture du nombre de points: DIMENSIONS nx ny nz
  const char* buf = 0;
  Integer nb_node_x = 0;
  Integer nb_node_y = 0;
  Integer nb_node_z = 0;
  {
    buf = vtk_file.getNextLine();
    istringstream iline(buf);
    std::string dimension_str;
    iline >> ws >> dimension_str >> ws >> nb_node_x
          >> ws >> nb_node_y >> ws >> nb_node_z;
    if (!iline){
      error() << "Erreur de syntaxe lors de la lecture des dimensions de la grille";
      return true;
    }
    vtk_file.checkString(dimension_str,"DIMENSIONS");
    if (nb_node_x<0 || nb_node_y<0 || nb_node_z<0 || nb_node_x+nb_node_y+nb_node_z<1){
      error() << "Dimensions invalides: x=" << nb_node_x << " y=" << nb_node_y << " z=" << nb_node_z;
      return true;
    }
  }
  
  info() << "Nombre de noeuds (x, y, z) = (" 
         << nb_node_x << ", "
         << nb_node_y << ", " 
         << nb_node_z << ")";
  Integer nb_node = nb_node_x * nb_node_y * nb_node_z;

  Real Ox = 0. ;
  Real Oy = 0. ;
  Real Oz = 0. ;
  Real dx = 0. ;
  Real dy = 0. ;
  Real dz = 0. ;
  Array<Real> dzf ;
  bool top_def = false ;
  bool top_file_read = false ;
  bool dz_def = false ;
  bool dz_file_read = false ;
  bool layer_top = false ;
  std::string top_file_str("Undefined") ;
  std::string dz_file_str("Undefined") ;
  // Lecture du nombre de points: POINTS nb float
  {
    buf = vtk_file.getNextLine();
    istringstream iline(buf);
    std::string origin_str;
    iline >> ws >> origin_str ;
    if(origin_str=="ORIGIN")
    {
      iline >> ws >> Ox >> ws >> Oy >> ws >> Oz;
      if (!iline){
        error() << "Erreur de syntaxe lors de la lecture des dimensions de la grille";
        return true;
      }
    }
    else
    {
      top_def = true ;
      if(origin_str=="TOP")
        {
          iline >> ws >> top_file_str ;
          if (!iline){
            error() << "Erreur de syntaxe lors de la lecture des données toit";
            return true;
          }
        }
    }
    vtk_file.checkString(origin_str,"ORIGIN","TOP");
  }
  {
    buf = vtk_file.getNextLine();
    istringstream iline(buf);
    std::string step_str;
    iline >> ws >> step_str ;
    if(step_str=="DXYZ")
    {
      iline >> ws >> dx >> ws >> dy >> ws >> dz;
      if (!iline){
        error() << "Erreur de syntaxe lors de la lecture des dimensions de la grille";
        return true;
      }
      layer_top = (dz<0) ;
    } 
    else if(step_str=="STEP")
    {
      warning() << "STEP keyword is deprecated; use DXYZ instead.";
      iline >> ws >> dx >> ws >> dy >> ws >> dz;
      if (!iline){
        error() << "Erreur de syntaxe lors de la lecture des dimensions de la grille";
        return true;
      }
      layer_top = (dz<0) ;
    } 
    else if(step_str=="DXY")
      {
        iline >> ws >> dx >> ws >> dy  ;
        if (!iline){
          error() << "Erreur de syntaxe lors de la lecture des dimensions de la grille";
          return true;
        }
        buf = vtk_file.getNextLine();
        istringstream iline2(buf);
        std::string stepz_str;
        iline2 >> ws >> stepz_str ;
        if(stepz_str=="DZ")
          {
            iline2 >> ws >> dz;
            if (!iline2){
              error() << "Erreur de syntaxe lors de la lecture des dimensions de la grille";
              return true;
            }
            layer_top = (dz<0) ;
          }
        else
          {
            if(stepz_str=="DZFILE")
            {
              dz_def = true ;
              iline2 >> ws >> dz_file_str;
              if (!iline2){
                error() << "Erreur de syntaxe lors de la lecture des dimensions de la grille";
                return true;
              }
              dzf.resize(nb_node_z) ;
              readBufferFromFile(dz_file_str,dzf,nb_node_z) ;
              layer_top = (dzf[0]<0) ;
            }
          }
      } 
    else 
    {
      // STEP est volontairement non listé dans l'ensemble des mots clefs car deprecated
      vtk_file.checkString(step_str,"DXYZ","DXY");
    }
  }
  
  Integer sub_domain_id = subDomain()->subDomainId();
  Integer nproc = pm->commSize() ;
  Integer rank = pm->commRank() ;
  
  info()<<" Number of domains "<<nproc;
  info()<<" Rank of current domain "<<rank;
  info()<<" Use internal partitioner :"<<use_internal_partition;

  Integer nb_cell_x = nb_node_x-1;
  Integer nb_cell_y = nb_node_y-1;
  Integer nb_cell_z = nb_node_z-1;
  Integer first_x = 0 ;
  Integer first_y = 0 ;
  Integer local_nb_node_x = nb_node_x ;
  Integer local_nb_node_y = nb_node_y ;
  Integer local_nb_cell_x = nb_cell_x ;
  Integer local_nb_cell_y = nb_cell_y ;

  if (use_internal_partition)
  {
    if(sub_domain_id!=0)
    {
      nb_node_x = 0;
      nb_node_y = 0;
      nb_node_z = 0;
      nb_cell_x = 0;
      nb_cell_y = 0;
      nb_cell_z = 0;
      local_nb_node_x = 0;
      local_nb_node_y = 0;
      local_nb_cell_x = 0;
      local_nb_cell_y = 0;
    }
  }
  else
  {
     Integer np1 = 1 ;
     Integer np2 = nproc ;
     _computePartition(nproc,&np1,&np2) ;
    Integer npx = np1 ;
    Integer npy = np2 ;
    if(nb_cell_x>nb_cell_y)
    {
       npx = np2 ;
       npy = np1 ;
    }
    Array<Integer> ix(npx+1) ;
    Integer ni = nb_cell_x/npx ;
    Integer ri = nb_cell_x%npx ;
    ix[0] = 0 ;
    for(Integer i=0;i<ri;i++)
       ix[i+1]=ix[i]+ni+1;
    for(Integer i=ri;i<npx;i++)
       ix[i+1]=ix[i]+ni;
    Array<Integer> jy(npy+1) ;
    Integer nj = nb_cell_y/npy ;
    // Integer rj = nb_cell_y%npy ;
    jy[0] = 0 ;
    for(Integer i=0;i<ri;i++)
       jy[i+1]=jy[i]+nj+1;
    for(Integer i=ri;i<npy;i++)
       jy[i+1]=jy[i]+nj;
    Integer rx = rank%npx ;
    Integer ry = rank/npx ;
    first_x = ix[rx] ;
    first_y = jy[ry] ;
    local_nb_node_x = ix[rx+1]-ix[rx]+1 ;
    local_nb_node_y = jy[ry+1]-jy[ry]+1 ;
    local_nb_cell_x = local_nb_node_x - 1 ;
    local_nb_cell_y = local_nb_node_y - 1 ;
    info()<<"Local nb node x"<<local_nb_node_x;
    info()<<"Local nb node y"<<local_nb_node_y;
    info()<<"Local nb cell x"<<local_nb_cell_x;
    info()<<"Local nb cell y"<<local_nb_cell_y;
    info()<<"NPX NPY "<<npx<<" "<<npy;
    for(Integer i=0;i<npx+1;i++)
       info()<<" ix["<<i<<"] "<<ix[i];
    for(Integer i=0;i<npy+1;i++)
       info()<<" jy["<<i<<"] "<<jy[i];
  }
  
  Integer nb_node_yz = nb_node_y*nb_node_z;
  Integer nb_node_xy = nb_node_x*nb_node_y;

  Integer nb_cell = nb_cell_x * nb_cell_y * nb_cell_z;
  
  Integer local_nb_cell = local_nb_cell_x * local_nb_cell_y * nb_cell_z;
  Integer local_nb_node = local_nb_node_x * local_nb_node_y * nb_node_z ;

  // Integer local_nb_node_yz = local_nb_node_y*nb_node_z;
  Integer local_nb_node_xy = local_nb_node_x*local_nb_node_y;
  
  CArrayInteger cells_local_id(local_nb_cell);
  CArrayInteger nodes_local_id(local_nb_node);
  
  info()<<"Total number of nodes : "<<nb_node;
  info()<<"Total number of cells : "<<nb_cell;
  info()<<"Local number of nodes : "<<local_nb_node;
  info()<<"Local number of cells : "<<local_nb_cell;
  info()<<"First X "<<first_x;
  info()<<"First Y "<<first_y;

  ////////////////////////////////////////////////////////////
  // Creation du maillage

  {
    CArrayInteger nodes_unique_id(local_nb_node);

    info() << " NODE YZ = " << nb_node_yz;
    // Cr?ation des noeuds
    Integer nb_node_local_id = 0;
    {
      Integer node_local_id = 0;
      for( Integer z=0; z<nb_node_z; ++z ){
        for( Integer y=first_y; y<first_y+local_nb_node_y; ++y ){
          for( Integer x=first_x; x<first_x+local_nb_node_x; ++x ){
            Integer node_unique_id = x + y*nb_node_x + z*nb_node_xy;
            nodes_unique_id[node_local_id] = node_unique_id;
            //Integer owner = sub_domain_id;
            //nodes_local_id[node_local_id] = node_local_id;
            
            ++node_local_id;
          }
        }
      }
      nb_node_local_id = node_local_id;
      warning() << " NB NODE LOCAL ID=" << node_local_id;
    }

    // Cr?ation des mailles
    
    // Infos pour la cr?ation des mailles
    // par maille: 1 pour son unique id,
    //             1 pour son type,
    //             8 pour chaque noeud
    CArrayInt64 cells_infos(local_nb_cell*10);
    Integer off_layer = 0 ;
    if(layer_top)
      off_layer = 4 ;
    {
      Integer cell_local_id = 0;
      Integer cells_infos_index = 0;

      for( Integer z=0; z<nb_cell_z; ++z ){
        for( Integer y=first_y; y<first_y+local_nb_cell_y; ++y ){
          for( Integer x=first_x; x<first_x+local_nb_cell_x; ++x ){
            Integer current_cell_nb_node = 8;
          
            //Integer cell_unique_id = y + (z)*nb_cell_y + x*nb_cell_y*nb_cell_z;
            Int64 cell_unique_id = x + y*nb_cell_x + z*nb_cell_x*nb_cell_y;
            cells_infos[cells_infos_index] = IT_Hexaedron8;
            ++cells_infos_index;

            cells_infos[cells_infos_index] = cell_unique_id;
            ++cells_infos_index;

            //Integer base_id = y + z*nb_node_y + x*nb_node_yz;
            Integer base_id = (x-first_x) + (y-first_y)*local_nb_node_x + z*local_nb_node_xy;
            cells_infos[cells_infos_index+0+off_layer] = nodes_unique_id[base_id];
            cells_infos[cells_infos_index+1+off_layer] = nodes_unique_id[base_id + 1];
            cells_infos[cells_infos_index+2+off_layer] = nodes_unique_id[base_id + local_nb_node_x + 1];
            cells_infos[cells_infos_index+3+off_layer] = nodes_unique_id[base_id + local_nb_node_x + 0];
            cells_infos[cells_infos_index+4-off_layer] = nodes_unique_id[base_id + local_nb_node_xy];
            cells_infos[cells_infos_index+5-off_layer] = nodes_unique_id[base_id + local_nb_node_xy + 1];
            cells_infos[cells_infos_index+6-off_layer] = nodes_unique_id[base_id + local_nb_node_xy + local_nb_node_x + 1];
            cells_infos[cells_infos_index+7-off_layer] = nodes_unique_id[base_id + local_nb_node_xy + local_nb_node_x + 0];
            cells_infos_index += current_cell_nb_node;
            cells_local_id[cell_local_id] = cell_local_id;
            ++cell_local_id;
          }
        }
      }
    }

    info()<<"Start building mesh"<<local_nb_cell<<" "<<cells_infos.size();
    mesh->setDimension(3) ;
    mesh->allocateCells(local_nb_cell,cells_infos,false);
    mesh->endAllocate();
    
    // Positionne les coordonn?es
    info()<<"Start creating mesh coordinates";
    {
      Array<Real3> coords(local_nb_node);
      Array<Real> topz ;
      Array<Real> dzf ; 
      if ((sub_domain_id==0)||(!use_internal_partition))
      {
        if(top_def)
        {
          topz.resize(nb_node_y*nb_node_x) ;
          top_file_read = readBufferFromFile(top_file_str,topz,nb_node_y*nb_node_x) ;
	  if (!top_file_read) {
	    error() << "Erreur de lecture du fichier TOP : " << top_file_str;
	    return true;
	  }
	}
	if(dz_def)
        {
          dzf.resize(nb_node_z) ;
          dz_file_read = readBufferFromFile(dz_file_str,dzf,nb_node_z) ;
	  if (!dz_file_read) {
	    error() << "Erreur de lecture du fichier DZFILE : " << dz_file_str;
	    return true;
	  }
        }
        Real nz = Oz ;
        Real tz = 0. ;
        for( Integer z=0; z<nb_node_z; ++z )
        {
          Real ny = Oy+first_y*dy ;
          for( Integer y=first_y; y<first_y+local_nb_node_y; ++y )
            {
              Real nx = Ox+first_x*dx ;
              for( Integer x=first_x; x<first_x+local_nb_node_x; ++x )
                {
                  // Integer node_unique_id = x + y*nb_node_x + z*nb_node_xy;
                  Integer node_local_id = (x-first_x) +(y-first_y)*local_nb_node_x + z*local_nb_node_xy;
                  if(top_def) tz = topz[y*nb_node_x+x] ;
                  coords[node_local_id] = Real3(nx,ny,nz+tz);
                  nx += dx ;
                }
              ny += dy ;
            }
          nz += dz ;
          if(dz_def) nz += dzf[z] ;
        }
      }
      VariableNodeReal3& nodes_coord_var(mesh->nodesCoordinates());
      ENUMERATE_NODE(inode,mesh->ownNodes()){
        const Node& node = *inode;
        Int64 node_unique_id = node.uniqueId();
        Int64 node_z = node_unique_id / nb_node_xy;
        Int64 node_y = (node_unique_id - node_z*nb_node_xy) / nb_node_x;
        Int64 node_x = node_unique_id - node_z*nb_node_xy - node_y*nb_node_x;
        Integer x = node_x - first_x ;
        Integer y = node_y - first_y ;
        Integer z = node_z ;
        Integer node_local_id = x +y*local_nb_node_x + z*local_nb_node_xy;
        //info()<<" Node : lid uid : "<<node_local_id<<" "<<node_unique_id<<" x,y,z : "<<x<<" "<<y<<" "<<z;
        nodes_coord_var[inode] = coords[node_local_id];
      }
      if(!use_internal_partition)
        nodes_coord_var.synchronize() ;
    }
  }

  // Cr?? les groupes de faces des c?t?s du parall?l?pip?de
  BufferT<Integer> xmin_surface_lid;
  BufferT<Integer> xmax_surface_lid;
  BufferT<Integer> ymin_surface_lid;
  BufferT<Integer> ymax_surface_lid;
  BufferT<Integer> zmin_surface_lid;
  BufferT<Integer> zmax_surface_lid;

  ENUMERATE_FACE(iface,mesh->allFaces()){
    const Face& face = *iface;
    Integer face_local_id = face.localId();
    bool is_xmin = true;
    bool is_xmax = true;
    bool is_ymin = true;
    bool is_ymax = true;
    bool is_zmin = true;
    bool is_zmax = true;
    for( NodeEnumerator inode(face.nodes()); inode(); ++inode ){
      const Node& node = *inode;
      Int64 node_unique_id = node.uniqueId();
      Int64 node_z = node_unique_id / nb_node_xy;
      Int64 node_y = (node_unique_id - node_z*nb_node_xy) / nb_node_x;
      Int64 node_x = node_unique_id - node_z*nb_node_xy - node_y*nb_node_x;
      if (node_x!=0)
        is_xmin = false;
      if (node_x!=(nb_node_x-1))
        is_xmax = false;
      if (node_y!=0)
        is_ymin = false;
      if (node_y!=(nb_node_y-1))
        is_ymax = false;
      if (node_z!=0)
        is_zmin = false;
      if (node_z!=(nb_node_z-1))
        is_zmax = false;
    }
    if (is_xmin)
      xmin_surface_lid.add(face_local_id);
    if (is_xmax)
      xmax_surface_lid.add(face_local_id);
    if (is_ymin)
      ymin_surface_lid.add(face_local_id);
    if (is_ymax)
      ymax_surface_lid.add(face_local_id);
    if (is_zmin)
      zmin_surface_lid.add(face_local_id);
    if (is_zmax)
      zmax_surface_lid.add(face_local_id);
      
  }
  _createFaceGroup(mesh,"XMIN",xmin_surface_lid);
  _createFaceGroup(mesh,"XMAX",xmax_surface_lid);
  _createFaceGroup(mesh,"YMIN",ymin_surface_lid);
  _createFaceGroup(mesh,"YMAX",ymax_surface_lid);
  _createFaceGroup(mesh,"ZMIN",zmin_surface_lid);
  _createFaceGroup(mesh,"ZMAX",zmax_surface_lid);

  ////////////////////////////////////////////////////////////
  // Lecture des paramètres optionnels

  info() << "Lecture des paramètres optionnels";

  std::string tag_zmin = "DEFAULT";
  std::string tag_zmax = "DEFAULT";
  std::string tag_ymin = "DEFAULT";
  std::string tag_ymax = "DEFAULT";
  std::string tag_xmin = "DEFAULT";
  std::string tag_xmax = "DEFAULT";

  bool ok = true ;
  do {
    buf = vtk_file.getNextLine(IfpVtkFile::OPTIONAL_LINE);
    if( buf == NULL ) break;
    istringstream iline(buf);

    // Lis le mot clé
    std::string keyword;
    iline >> ws >> keyword;

    if( keyword == "TAGS" ) {
      // Lecture des étiquettes associées aux faces du parallélépipède
      // pour le conditions au bord dans l'ordre suivant:
      // z = zmin, z = zmax, y = ymin, y = ymax, x = xmin, x = xmax  

      iline >> ws >> tag_zmin >> ws >> tag_zmax
            >> ws >> tag_ymin >> ws >> tag_ymax
            >> ws >> tag_xmin >> ws >> tag_xmax;
      if(!iline) {
        error() << "Erreur de syntaxe lors de la lecture des étiquettes associées aux faces de bord";
        return true;
      }
      info() << "Etiquettes associées aux faces de bord:";
      info() << "(z = zmin, z = zmax, y = ymin, y = ymax, x = xmin, x = xmax) = ("
             << tag_zmin << ", " << tag_zmax << ", "
             << tag_ymin << ", " << tag_ymax << ", "
             << tag_xmin << ", " << tag_xmax << ")";
    } else if( keyword == "CELLGROUPS" ) {
      Integer nb_groups = 0 ;
      iline >> ws >> nb_groups;
      if (!iline){
        error() << "Erreur de syntaxe lors de la lecture des groupes de cellules";
        return true;
      }
      for(Integer igroup = 0; igroup < nb_groups; igroup++)
        _createItemGroup(mesh, vtk_file, buf, nb_cell_x, nb_cell_y, nb_cell_z, 
                         first_x,local_nb_cell_x,first_y,local_nb_cell_y,IK_Cell,
                         use_internal_partition) ;
    } else if( keyword == "NODEGROUPS" ) {
      Integer nb_groups = 0 ;
      if (!iline){
        error() << "Erreur de syntaxe lors de la lecture des groupes de noeuds";
        return true;
      }
      for(Integer igroup=0;igroup<nb_groups;igroup++)
        _createItemGroup(mesh, vtk_file, buf, nb_node_x, nb_node_y, nb_node_z, 
                         first_x,local_nb_node_y,first_y,local_nb_node_y,IK_Node,
                         use_internal_partition);
    } else if(( keyword == "CELL_DATA")||( keyword == "POINT_DATA")) { 
      // Maintenant, regarde s'il existe des données associées cell aux fichiers
        ok = _readData( mesh,
                            vtk_file,
                            use_internal_partition,
                            nodes_local_id,
                            cells_local_id,
                            buf );
        if(ok) return true ;
    } else {
      error() << "Mot clé [" << keyword << "] inconnu";
      return true;
    }
  } while( ok );

  // Create face groups for boundary conditions
  // The prefix "BC_" is added to the boundary condition name by default 
  // in order to avoid group name collisions
  info() << "Création des groupes pour les conditions au bord";

  if( mesh->findGroup( "BC_" + tag_zmin ).null() )
    _createFaceGroup(mesh, "BC_" + tag_zmin, zmin_surface_lid);
  else
    error() << "FATAL: Group with reserved name BC_" + tag_zmin
            << " already exists";

  if( mesh->findGroup( "BC_" + tag_zmax ).null() )
    _createFaceGroup(mesh, "BC_" + tag_zmax, zmax_surface_lid);
  else
    mesh->findGroup( "BC_" + tag_zmax ).addItems( zmax_surface_lid );

  if( mesh->findGroup( "BC_" + tag_ymin ).null() )
    _createFaceGroup(mesh, "BC_" + tag_ymin, ymin_surface_lid);
  else
    mesh->findGroup( "BC_" + tag_ymin ).addItems( ymin_surface_lid );

  if( mesh->findGroup( "BC_" + tag_ymax ).null() )
    _createFaceGroup(mesh, "BC_" + tag_ymax, ymax_surface_lid);
  else
    mesh->findGroup( "BC_" + tag_ymax ).addItems( ymax_surface_lid );

  if( mesh->findGroup( "BC_" + tag_xmin ).null() )
    _createFaceGroup(mesh, "BC_" + tag_xmin, xmin_surface_lid);
  else
    mesh->findGroup( "BC_" + tag_xmin ).addItems( xmin_surface_lid );

  if( mesh->findGroup( "BC_" + tag_xmax ).null() )
    _createFaceGroup(mesh, "BC_" + tag_xmax, xmax_surface_lid);
  else
    mesh->findGroup( "BC_" + tag_xmax ).addItems( xmax_surface_lid );
  
  return false ;
}


void IfpVtkMeshIOService::
_readDistStructuredFacesMesh(IWritableMesh* mesh,const String& file_name,const String& dir_name,bool use_internal_partition)
{
  // const char* func_name = "IfpVtkMeshIOService::_readFacesMesh()";
  // ITraceMng* msg = subDomain()->traceMng();

  IParallelMng* pm = subDomain()->parallelMng();
  Integer sid = pm->commRank() ; 
  // Si on utilise le partitionneur interne, seul le sous-domaine lit le maillage
  bool need_read = true;
  if (use_internal_partition)
    need_read = (sid==0);

  ifstream ifile(file_name.localstr());
  if (!ifile){
    info() << "Aucun fichier descriptif des faces '" << file_name << "'";
    return;
  }
  IfpVtkFile vtk_file(&ifile);
  const char* buf = 0;
  Integer nb_node_x = 0;
  Integer nb_node_y = 0;
  Integer nb_node_z = 0;
  Integer nb_face = 0 ;
  Integer nb_face_node = 0 ;
  if((sid==0) ||(!use_internal_partition))
  {
    {
      buf = vtk_file.getNextLine();
      istringstream iline(buf);
      std::string dimension_str;
      iline >> ws >> dimension_str >> ws >> nb_node_x
            >> ws >> nb_node_y >> ws >> nb_node_z;
      if (!iline){
        error() << "Erreur de syntaxe lors de la lecture des dimensions de la grille";
        return ;
      }
      vtk_file.checkString(dimension_str,"DIMENSIONS");
      if (nb_node_x<0 || nb_node_y<0 || nb_node_z<0 || nb_node_x+nb_node_y+nb_node_z<1){
        error() << "Dimensions invalides: x=" << nb_node_x << " y=" << nb_node_y << " z=" << nb_node_z;
        return ;
      }
    }
    {
      buf = vtk_file.getNextLine();
      istringstream iline(buf);
      std::string faces_str;
      iline >> ws >> faces_str >> ws >> nb_face;
      vtk_file.checkString(faces_str,"FACES");
      if (nb_face<0){
        error() << "Dimensions invalides: numbre de face=" << nb_face;
        return ;
      }
    }
  
    info() << " Infos: " << nb_node_x << " " << nb_node_y << " " << nb_node_z;
    info() << " Nombre de faces: " << nb_face;
  }
  
  Integer sub_domain_id = subDomain()->subDomainId();
  Integer nproc = pm->commSize() ;
  Integer rank = pm->commRank() ;
  
  info()<<" Number of domains "<<nproc;
  info()<<" Rank of current domain "<<rank;
  info()<<" Use internal partitioner :"<<use_internal_partition;

  Integer nb_cell_x = nb_node_x-1;
  Integer nb_cell_y = nb_node_y-1;
  Integer nb_cell_z = nb_node_z-1;
  Integer first_x = 0 ;
  Integer first_y = 0 ;
  Integer local_nb_node_x = nb_node_x ;
  Integer local_nb_node_y = nb_node_y ;
  Integer local_nb_cell_x = nb_cell_x ;
  Integer local_nb_cell_y = nb_cell_y ;

  if (use_internal_partition)
  {
    if(sub_domain_id!=0)
    {
      nb_node_x = 0;
      nb_node_y = 0;
      nb_node_z = 0;
      nb_cell_x = 0;
      nb_cell_y = 0;
      nb_cell_z = 0;
      local_nb_node_x = 0;
      local_nb_node_y = 0;
      local_nb_cell_x = 0;
      local_nb_cell_y = 0;
    }
  }
  else
  {
     Integer np1 = 1 ;
     Integer np2 = nproc ;
     _computePartition(nproc,&np1,&np2) ;
    Integer npx = np1 ;
    Integer npy = np2 ;
    if(nb_cell_x>nb_cell_y)
    {
       npx = np2 ;
       npy = np1 ;
    }
    Array<Integer> ix(npx+1) ;
    Integer ni = nb_cell_x/npx ;
    Integer ri = nb_cell_x%npx ;
    ix[0] = 0 ;
    for(Integer i=0;i<ri;i++)
       ix[i+1]=ix[i]+ni+1;
    for(Integer i=ri;i<npx;i++)
       ix[i+1]=ix[i]+ni;
    Array<Integer> jy(npy+1) ;
    Integer nj = nb_cell_y/npy ;
    // Integer rj = nb_cell_y%npy ;
    jy[0] = 0 ;
    for(Integer i=0;i<ri;i++)
       jy[i+1]=jy[i]+nj+1;
    for(Integer i=ri;i<npy;i++)
       jy[i+1]=jy[i]+nj;
    Integer rx = rank%npx ;
    Integer ry = rank/npx ;
    first_x = ix[rx] ;
    first_y = jy[ry] ;
    local_nb_node_x = ix[rx+1]-ix[rx]+1 ;
    local_nb_node_y = jy[ry+1]-jy[ry]+1 ;
    local_nb_cell_x = local_nb_node_x - 1 ;
    local_nb_cell_y = local_nb_node_y - 1 ;
    info()<<"Local nb node x"<<local_nb_node_x;
    info()<<"Local nb node y"<<local_nb_node_y;
    info()<<"Local nb cell x"<<local_nb_cell_x;
    info()<<"Local nb cell y"<<local_nb_cell_y;
    info()<<"NPX NPY "<<npx<<" "<<npy;
    for(Integer i=0;i<npx+1;i++)
       info()<<" ix["<<i<<"] "<<ix[i];
    for(Integer i=0;i<npy+1;i++)
       info()<<" jy["<<i<<"] "<<jy[i];
  }
  // Integer local_nb_node_yz = local_nb_node_y*nb_node_z;
  // Integer local_nb_node_xy = local_nb_node_x*local_nb_node_y;

  info()<<"First X "<<first_x;
  info()<<"First Y "<<first_y;

  
  
  
  CArrayInteger faces_local_id(nb_face);
  if((sid==0)||(!use_internal_partition))
  {
    // Lecture des infos des faces
    // Lecture de la connectivit?
    Array<Integer> faces_nb_node;
    Array<Int64> faces_connectivity;
    Array<Integer> faces_type;
    nb_face_node=4*nb_face ;
    faces_nb_node.resize(nb_face);
    faces_type.resize(nb_face);
    faces_connectivity.resize(nb_face_node);
    {
      Integer connectivity_index = 0;
      for( Integer iface=0; iface<nb_face; ++iface )
      {
        Integer i = vtk_file.getInteger();
        Integer j = vtk_file.getInteger();
        Integer k = vtk_file.getInteger();
        Integer l = vtk_file.getInteger();
        if( (i>=first_x)&&(i<first_x+local_nb_cell_x)&&
            (j>=first_y)&&(j<first_y+local_nb_cell_y) )
        {
          if(l<0||l>2) error()<<"l:"<<l<<"out of range";
          faces_nb_node[iface] = 4;
          if(l==0)
            {
              if(check(i,j,k,nb_node_x,nb_node_y,nb_node_z)) return ;
              faces_connectivity[connectivity_index] = k*(nb_node_x*nb_node_y)+j*nb_node_x+i;
              i++ ;
              ++connectivity_index;
              if(check(i,j,k,nb_node_x,nb_node_y,nb_node_z)) return ;
              faces_connectivity[connectivity_index] = k*(nb_node_x*nb_node_y)+j*nb_node_x+i;
              j++ ;
              ++connectivity_index;
              if(check(i,j,k,nb_node_x,nb_node_y,nb_node_z)) return ;
              faces_connectivity[connectivity_index] = k*(nb_node_x*nb_node_y)+j*nb_node_x+i;
              i--;
              ++connectivity_index;
              if(check(i,j,k,nb_node_x,nb_node_y,nb_node_z)) return ;
              faces_connectivity[connectivity_index] = k*(nb_node_x*nb_node_y)+j*nb_node_x+i;
              ++connectivity_index;
            }
          if(l==1)
            {
              if(check(i,j,k,nb_node_x,nb_node_y,nb_node_z)) return ;
              faces_connectivity[connectivity_index] = k*(nb_node_x*nb_node_y)+j*nb_node_x+i;
              i++ ;
              ++connectivity_index;
              if(check(i,j,k,nb_node_x,nb_node_y,nb_node_z)) return ;
              faces_connectivity[connectivity_index] = k*(nb_node_x*nb_node_y)+j*nb_node_x+i;
              k++ ;
              ++connectivity_index;
              if(check(i,j,k,nb_node_x,nb_node_y,nb_node_z)) return ;
              faces_connectivity[connectivity_index] = k*(nb_node_x*nb_node_y)+j*nb_node_x+i;
              i--;
              ++connectivity_index;
              if(check(i,j,k,nb_node_x,nb_node_y,nb_node_z)) return ;
              faces_connectivity[connectivity_index] = k*(nb_node_x*nb_node_y)+j*nb_node_x+i;
              ++connectivity_index;
            }
          if(l==2)
            {
              if(check(i,j,k,nb_node_x,nb_node_y,nb_node_z)) return ;
              faces_connectivity[connectivity_index] = k*(nb_node_x*nb_node_y)+j*nb_node_x+i;
              j++ ;
              ++connectivity_index;
              if(check(i,j,k,nb_node_x,nb_node_y,nb_node_z)) return ;
              faces_connectivity[connectivity_index] = k*(nb_node_x*nb_node_y)+j*nb_node_x+i;
              k++ ;
              ++connectivity_index;
              if(check(i,j,k,nb_node_x,nb_node_y,nb_node_z)) return ;
              faces_connectivity[connectivity_index] = k*(nb_node_x*nb_node_y)+j*nb_node_x+i;
              j--;
              ++connectivity_index;
              if(check(i,j,k,nb_node_x,nb_node_y,nb_node_z)) return ;
              faces_connectivity[connectivity_index] = k*(nb_node_x*nb_node_y)+j*nb_node_x+i;
              ++connectivity_index;
            }
        }
        faces_type[iface] = IT_Quad4 ;
      }
    }
    
    // Il faut ? partir de la connectivit? retrouver les localId() des faces
    //faces_local_id.resize(nb_face);
    {
      IMeshUtilities* mu = mesh->utilities();
      mu->localIdsFromConnectivity(IK_Face,faces_nb_node,faces_connectivity,faces_local_id);
    }
  }
    
  // Maintenant, regarde s'il existe des donn?es associ?es aux fichier
  _readFaceData(mesh,vtk_file,use_internal_partition,IK_Face,faces_local_id);
}
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ARCANE_END_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
