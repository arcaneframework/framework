set(PKGS LibUnwind Papi Parmetis PTScotch Udunits Zoltan HDF5 MPI MKL BZip2 LZ4 Otf2 DbgHelp)
# HWLoc est pour l'instant incompatible avec MPC (probablement pas completement thread-safe)
# NOTE: Cela n'a pas été testé depuis 2011.
if(NOT ARCANE_USE_MPC)
  list(APPEND PKGS HWLoc)
endif()

foreach(package ${PKGS})
  arcane_find_package(${package})
endforeach()

# Pour MEDFile, il faut HDF5 mais le find_package fait planter CMake (avec MED 4.0.0)
# si HDF5 n'est pas trouvé. On ne fait donc le find_package que si HDF5
# est trouvé
if(HDF5_FOUND)
  list(APPEND PKGS MEDFile)
  arcane_find_package(MEDFile QUIET)
endif()

include(srcs.cmake)

if(BZIP2_FOUND)
  set(ARCANE_SOURCES ${ARCANE_SOURCES} Bzip2DeflateService.cc)
endif()
if(LZ4_FOUND)
  set(ARCANE_SOURCES ${ARCANE_SOURCES} LZ4DeflateService.cc)
endif()
if(HDF5_FOUND)
  set(ARCANE_SOURCES ${ARCANE_SOURCES}
    Hdf5Utils.cc
    Hdf5VariableInfoBase.cc
    Hdf5ReaderWriter.cc
    Hdf5VariableReader.cc
    Hdf5VariableWriter.cc
    Hdf5MpiReaderWriter.cc
    EnsightHdfPostProcessor.cc
    )
endif()

if(MEDFILE_FOUND)
  set( ARCANE_SOURCES ${ARCANE_SOURCES} MEDMeshReaderService.cc)
endif()
if (Parmetis_FOUND)
  list(APPEND ARCANE_SOURCES
    MetisMeshPartitioner.cc
    MetisGraphDigest.cc
    MetisGraphGather.cc
    MetisWrapper.cc
    MetisGraph.h
    MetisGraphDigest.h
    MetisGraphGather.h
    MetisWrapper.h
)
endif()
if(ZOLTAN_FOUND)
  set( ARCANE_SOURCES ${ARCANE_SOURCES} ZoltanMeshPartitioner.cc)
endif()
if(PTSCOTCH_FOUND)
  set( ARCANE_SOURCES ${ARCANE_SOURCES} PTScotchMeshPartitioner.cc)
endif()
if(LIBUNWIND_FOUND)
  set( ARCANE_SOURCES ${ARCANE_SOURCES} LibUnwindStackTraceService.cc)
endif()
if(UDUNITS_FOUND)
  set( ARCANE_SOURCES ${ARCANE_SOURCES} UdunitsPhysicalUnitSystemService.cc)
endif()
if(PAPI_FOUND)
  set( ARCANE_SOURCES ${ARCANE_SOURCES} PapiPerformanceService.cc)
endif()
if(PERFMON_FOUND)
  set( ARCANE_SOURCES ${ARCANE_SOURCES} PerfmonPerformanceService.cc)
endif()
if(LIBUNWIND_FOUND)
  set( ARCANE_SOURCES ${ARCANE_SOURCES} ProfPerformanceService.cc)
endif()
if(HWLOC_FOUND)
  set( ARCANE_SOURCES ${ARCANE_SOURCES} HWLocProcessorAffinity.cc)
endif()
if(MKL_FOUND)
  set( ARCANE_SOURCES ${ARCANE_SOURCES} MKLVectorMathService.cc)
endif()
if(OTF2_FOUND)
  if (TARGET Arccore::arccore_message_passing_mpi)
    # Récupère le numéro de version de Otf2 et vérifie qu'il s'agit
    # de la version 2.1.
    # TODO: à terme mettre cette détection dans Arccon.
    find_file(_OTF_GEN_DEF NAMES otf2/OTF2_GeneralDefinitions.h HINTS ${OTF2_INCLUDE_DIRS})
	  if (_OTF_GEN_DEF)
      set(OTF2_REQUIRED_VERSION "2.1")
      file(STRINGS ${_OTF_GEN_DEF} _OTF_GEN_DEF_CONTENT REGEX "OTF2_VERSION")
      string(REGEX MATCH "OTF2_VERSION_MAJOR[ ]+([0-9]+).*OTF2_VERSION_MINOR[ ]+([0-9]+)" OTF2_VERSION_MATCH ${_OTF_GEN_DEF_CONTENT})
      set(OTF2_VERSION "${CMAKE_MATCH_1}.${CMAKE_MATCH_2}")
      message(STATUS "[Otf2] Found version '${OTF2_VERSION}' (required=${OTF2_REQUIRED_VERSION})")
      if (OTF2_VERSION VERSION_LESS ${OTF2_REQUIRED_VERSION})
        message(FATAL_ERROR
          "[Otf2] Found version (${OTF2_VERSION}) of Otf2 is too old."
          " Version '${OTF2_REQUIRED_VERSION}+' is required."
          " You may disable 'Otf2' if you add '-DCMAKE_DISABLE_FIND_PACKAGE_Otf2=TRUE'"
          " to CMmake arguments during configuration"
          )
      endif()
    else()
      message(FATAL_ERROR "Can not determine OTF2 Version")
    endif()
    list(APPEND ARCANE_SOURCES
      Otf2MessagePassingProfilingService.cc
      Otf2MpiProfiling.cc
      Otf2LibWrapper.cc
      )
  endif()
endif()
if(DbgHelp_FOUND)
  list(APPEND ARCANE_SOURCES 
    DbgHelpStackTraceService.cc
    )
endif()

arcane_add_library(arcane_std
  INPUT_PATH ${Arcane_SOURCE_DIR}/src
  RELATIVE_PATH arcane/std
  FILES ${ARCANE_SOURCES}
  AXL_FILES ${AXL_FILES}
)

# ----------------------------------------------------------------------------

if (${ARCANE_HAS_MALLOC_HOOKS})
  target_compile_definitions(arcane_std PRIVATE ARCANE_USE_MALLOC_HOOK)
endif()

if (TARGET Arccore::arccore_message_passing_mpi)
  target_link_libraries(arcane_std PUBLIC Arccore::arccore_message_passing_mpi)
endif()
target_link_libraries(arcane_std PUBLIC ${ARCANE_BASE_LIBRARIES})

# TODO: il semblerait qu'on ait besoin de rajouter stdc++fs pour que link passe avec le
# std::filesystem du c++17 pour le moment, a enlever quand ce sera possible
if (OTF2_FOUND AND UNIX)
  target_link_libraries(arcane_std PUBLIC stdc++fs)
endif()

arcane_add_arccon_packages(arcane_std PRIVATE ${PKGS})

arcane_register_library(arcane_std)

# ----------------------------------------------------------------------------
# Local Variables:
# tab-width: 2
# indent-tabs-mode: nil
# coding: utf-8-with-signature
# End:
