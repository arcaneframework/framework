// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
#ifndef ARCGEOSIM_GEOMETRY_IGEOMETRYSERVICE_H
#define ARCGEOSIM_GEOMETRY_IGEOMETRYSERVICE_H
/* Author : havep at Wed Nov 14 13:41:31 2007
 * Generated by createNew
 */

#include <arcane/ItemGroup.h>
#include <arcane/ArcaneTypes.h>
#include <arcane/MeshVariable.h>
#include <arcane/VariableTypedef.h>
#include <arcane/utils/String.h>

using namespace Arcane;

namespace Arcane
{
namespace Numerics
{

//! Interface for local geometry computations
class IGeometry;

//! Geometric properties
/*! Some of them are contextual. 
 *  For example, the PMeasure of a 3D cell is its PVolume.
 * 
 *  Technical notes: A external container given by the user cannot
 *  be used for anything except the given property.
 *  An internal ItemGroupMap cannot be allocated for a group different 
 *  of the group wished by the used.
 */
struct ARCANE_GEOMETRY_EXPORT IGeometryProperty 
{
  enum eProperty
    {
      PNone               = 0,
      PMeasure            = (1 << 0),
      PLength             = (1 << 1),
      PArea               = (1 << 2),
      PVolume             = (1 << 3),
      PCenter             = (1 << 4),
      PNormal             = (1 << 5),
      PVolumeSurfaceRatio = (1 << 6),
      PEnd                = (1 << 7) //! Marqueur de dernier type
    };

  enum eStorage
  { 
    PNoStorage    = 0,
    PVariable     = (1 << 0)
  };

  static bool isScalar(const eProperty p) 
  {
    return (p & (PMeasure|PLength|PArea|PVolume|PVolumeSurfaceRatio)) != 0;
  }

  static bool isVectorial(const eProperty p) 
  {
    return (p & (PCenter|PNormal)) != 0;
  }

  class Enumerator
  {
  public:
    Enumerator() : m_state(1) { }
    eProperty operator*() const { return (eProperty)m_state; }
    void operator++() { m_state <<= 1; }
    bool end() const { return m_state == PEnd; }
    private:
      Integer m_state;
  };

  static String name(const eProperty p) {
    switch (p) {
    case PNone:
      return "None";
    case PMeasure:
      return "Measure";
    case PLength:
      return "Length";
    case PArea:
      return "Area";
    case PVolume:
      return "Volume";        
    case PCenter:
      return "Center";
    case PNormal:
      return "Normal";
    case PVolumeSurfaceRatio:
      return "VolumeSurfaceRatio";
    case PEnd:
    default:
      ARCANE_FATAL("Undefined property");
    }
  }

  static String name(const eStorage p) {
    switch (p) {
    case PNoStorage:
      return "NoStorage";
    case PVariable:
      return "Variable";
    default:
      ARCANE_FATAL("Undefined storage");
    }
  }
};
/*!
 * \brief Gestionnaire des calculs gÃ©omÃ©triques.
 */
class ARCANE_GEOMETRY_EXPORT IGeometryMng
{
 public:
  typedef VariableItemReal RealVariable;
  typedef VariableItemReal3 Real3Variable;

 public:
  /** Constructeur de la classe */
  IGeometryMng() {}
  
  /** Destructeur de la classe */
  virtual ~IGeometryMng() {};
  
public:
  //! Initialisation
  virtual void init() = 0;

  //@{ @name Geometric property management for ItemGroup 

  //! Set geometric properties on a ItemGroup
  virtual void addItemGroupProperty(ItemGroup group, Integer property, Integer storage = IGeometryProperty::PVariable) = 0;

  //! Set geometric properties on a ItemGroup with an external container (real field)
  virtual void addItemGroupProperty(ItemGroup group, IGeometryProperty::eProperty property, RealVariable var) = 0;

  //! Set geometric properties on a ItemGroup with an external container (real3 field)
  virtual void addItemGroupProperty(ItemGroup group, IGeometryProperty::eProperty property, Real3Variable var) = 0;

  //! Get set of properties of an ItemGroup
  virtual Integer getItemGroupProperty(ItemGroup group) = 0;

  //! Check if a property is activated on an ItemGroup
  virtual bool hasItemGroupProperty(ItemGroup group, Integer property) = 0;

  //! Check if a storage is available on an ItemGroup
  virtual Integer getItemGroupPropertyStorage(ItemGroup group, IGeometryProperty::eProperty property) = 0;

  //@}

  //@{ @name Access to geometric values

  //! Get geometric property values for a Real field
  virtual const RealVariable & getRealVariableProperty(ItemGroup group, IGeometryProperty::eProperty property) = 0;

  //! Get geometric property values for a Real3 field
  virtual const Real3Variable & getReal3VariableProperty(ItemGroup group, IGeometryProperty::eProperty property) = 0;

  //@}

  //@{ @name property management by group and properties

  //! Update property values for an ItemGroup
  virtual void update(ItemGroup group, Integer property) = 0;

  //! Reset property for an ItemGroup
  virtual void reset(ItemGroup group, Integer property) = 0;
  
  //@}

  //@{ @name property management by group

  //! Update property values for an ItemGroup
  virtual void update(ItemGroup group) = 0;

  //! Reset property for an ItemGroup
  virtual void reset(ItemGroup group) = 0;
  
  //@}

  //@{ @name global property management 

  //! Update property values for all ItemGroups
  virtual void update() = 0;

  //! Reset property for all ItemGroups
  virtual void reset() = 0;
  
  //@}

  //! Get underlying geometry
  virtual IGeometry * geometry() = 0;
};

} // End namespace Arcane

} // End namespace Numerics

#endif /* ARCGEOSIM_GEOMETRY_IGEOMETRYSERVICE_H */
