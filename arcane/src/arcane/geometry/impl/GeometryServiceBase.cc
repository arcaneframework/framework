// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2023 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
#include "GeometryServiceBase.h"
/* Author : havep at Thu Apr  3 09:09:09 2008
 * Generated by createNew
 */

#include <arcane/IMesh.h>
using namespace Arcane;

#include <arcane/IItemOperationByBasicType.h>
#include <arcane/IItemFamily.h>
#include <arcane/ArcaneVersion.h>
#include <arcane/ItemVectorView.h>

#include <set>

ARCANE_BEGIN_NAMESPACE
NUMERICS_BEGIN_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

GeometryServiceBase::
GeometryServiceBase()
{
  m_suffix = String("By") + (unsigned long)(this);
}

GeometryServiceBase::
~GeometryServiceBase()
{
  ;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void GeometryServiceBase::
addItemGroupProperty(ItemGroup group, Integer property, Integer storage)
{
  ItemGroupGeometryProperty& properties = m_group_property_map[group.internal()];
  properties.defined |= property;
  Integer current_property = 1;
  while (property) {
    if (property & current_property) {
      properties.storages[static_cast<IGeometryProperty::eProperty>(current_property)].storageType |= storage;
      traceMng()->debug() << "Add geometric property ["
                          << IGeometryProperty::name(static_cast<IGeometryProperty::eProperty>(current_property))
                          << "] on group " << group.name();
    }
    property &= ~current_property;
    current_property <<= 1;
  }
}

void GeometryServiceBase::
addItemGroupProperty(ItemGroup group, IGeometryProperty::eProperty property, RealVariable var)
{
  ARCANE_ASSERT((IGeometryProperty::isScalar(property)), ("Scalar property expected"));
  ItemGroupGeometryProperty& properties = m_group_property_map[group.internal()];
  ItemGroupGeometryProperty::StorageInfo& storage = properties.storages[property];
  if (storage.realVar) {
    if (storage.realVar->name() != var.name())
      traceMng()->fatal() << "Geometric property [" << IGeometryProperty::name(property)
                          << "] storage already defined on group " << group.name() 
                          << " with variable " << storage.realVar->name();
    ARCANE_ASSERT((properties.defined & property), ("Unconsistent state with undefined property with defined variable"));
    return;
  }
  properties.defined |= property;
  storage.realVar.reset(new RealVariable(var));
  storage.storageType |= IGeometryProperty::PVariable;
  storage.externStorage |= IGeometryProperty::PVariable;
  // #ifndef NO_USER_WARNING
  // #warning "Ne plus allouer d'ItemGroupMap implicitement"
  // #endif /* NO_USER_WARNING */
  //   storage.realMap.reset(new RealGroupMap(group));
  //   storage.storageType |= IGeometryProperty::PItemGroupMap;
}

void GeometryServiceBase::
addItemGroupProperty(ItemGroup group, IGeometryProperty::eProperty property, Real3Variable var)
{
  ARCANE_ASSERT((IGeometryProperty::isVectorial(property)), ("Vectorial property expected"));
  ItemGroupGeometryProperty& properties = m_group_property_map[group.internal()];
  ItemGroupGeometryProperty::StorageInfo& storage = properties.storages[property];
  if (storage.real3Var) {
    if (storage.real3Var->name() != var.name())
      traceMng()->fatal() << "Geometric property [" << IGeometryProperty::name(property)
                          << "] storage already defined on group " << group.name() 
                          << " with variable " << storage.real3Var->name();
    ARCANE_ASSERT((properties.defined & property), ("Unconsistent state with undefined property with defined variable"));
    return;
  }
  properties.defined |= property;
  storage.real3Var.reset(new Real3Variable(var));
  storage.storageType |= IGeometryProperty::PVariable;
  storage.externStorage |= IGeometryProperty::PVariable;
  // #ifndef NO_USER_WARNING
  // #warning "Ne plus allouer d'ItemGroupMap implicitement"
  // #endif /* NO_USER_WARNING */
  //   storage.real3Map.reset(new Real3GroupMap(group));
  //   storage.storageType |= IGeometryProperty::PItemGroupMap;
}

Integer
GeometryServiceBase::
getItemGroupProperty(ItemGroup group)
{
  PropertyMap::const_iterator iprop = m_group_property_map.find(group.internal());
  if (iprop == m_group_property_map.end())
    return IGeometryProperty::PNone;
  return iprop->second.defined;
}

bool GeometryServiceBase::
hasItemGroupProperty(ItemGroup group, Integer property)
{
  return (getItemGroupProperty(group) & property) == property;
}

Integer
GeometryServiceBase::
getItemGroupPropertyStorage(ItemGroup group, IGeometryProperty::eProperty property)
{
  PropertyMap::const_iterator iprop = m_group_property_map.find(group.internal());
  if (iprop == m_group_property_map.end())
    return IGeometryProperty::PNoStorage;
  return iprop->second.getStorage(property);
}

/*---------------------------------------------------------------------------*/

const IGeometryMng::RealVariable&
GeometryServiceBase::
getRealVariableProperty(ItemGroup group, IGeometryProperty::eProperty property)
{
  if (!IGeometryProperty::isScalar(property))
    traceMng()->fatal() << "Non scalar property requested by scalar interface";
  ItemGroupGeometryProperty::StorageInfo& storage = _checkItemGroupProperty(group.internal(), property, IGeometryProperty::PVariable);
  std::shared_ptr<RealVariable>& pvar = storage.realVar;
  if (!pvar)
    throw FatalErrorException(A_FUNCINFO, "Unexpected missing scalar field");
  storage.usageVarCount++;
  return *pvar;
}

const IGeometryMng::Real3Variable&
GeometryServiceBase::
getReal3VariableProperty(ItemGroup group, IGeometryProperty::eProperty property)
{
  if (!IGeometryProperty::isVectorial(property))
    traceMng()->fatal() << "Non vectorial property requested by vectorial interface";
  ItemGroupGeometryProperty::StorageInfo& storage = _checkItemGroupProperty(group.internal(), property, IGeometryProperty::PVariable);
  std::shared_ptr<Real3Variable>& pvar = storage.real3Var;
  if (!pvar)
    throw FatalErrorException(A_FUNCINFO, "Unexpected missing vectorial field");
  storage.usageVarCount++;
  return *pvar;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void GeometryServiceBase::
update(ItemGroup group, [[maybe_unused]] Integer property)
{
  update(group);
}

void GeometryServiceBase::
reset(ItemGroup group, [[maybe_unused]] Integer property)
{
  reset(group);
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void GeometryServiceBase::
update()
{
  Trace::Setter setter(traceMng(), className());

  _checkItemGroupUsage();
  _resetComputeFlags();

  IMesh* mesh = this->mesh();
  //
  const eItemKind all_kinds[] = { IK_Face, IK_Cell };
  const Integer all_kind_size = sizeof(all_kinds) / sizeof(eItemKind);

  for (Integer ikind = 0; ikind < all_kind_size; ++ikind) {
    const eItemKind current_kind = all_kinds[ikind];
    IItemFamily* family = mesh->itemFamily(current_kind);
    ItemGroup allItemGroup = family->allItems();

    if (m_group_property_map.find(allItemGroup.internal()) != m_group_property_map.end()) {
      // Delegate all geometric properties already planned for allItems
      ItemGroupGeometryProperty& all_group_property = m_group_property_map[allItemGroup.internal()];
      update(allItemGroup);

      for (PropertyMap::iterator igroup = m_group_property_map.begin(); igroup != m_group_property_map.end(); ++igroup) {
        ItemGroup group(igroup->first);
        if (group.itemKind() == current_kind) {
          ItemGroupGeometryProperty& group_property = igroup->second;
          for (ItemGroupGeometryProperty::StorageInfos::const_iterator iprop = group_property.storages.begin();
               iprop != group_property.storages.end(); ++iprop) {
            const IGeometryProperty::eProperty property = iprop->first;
            ItemGroupGeometryProperty::StorageInfo& storage = group_property.storages[property];

            if (property & all_group_property.defined) // propriétés communes avec allItemGroup
            {
              // Is a scalar property
              if (IGeometryProperty::isScalar(property)) {
#ifndef NO_USER_WARNING
#warning "failed when ItemGroupMap storage only on allItems group"
#endif
                RealVariable& var = *all_group_property.storages[property].realVar;

                // Need Variable storage for that property ?
                if (storage.storageType & IGeometryProperty::PVariable) {
                  if (storage.externStorage & IGeometryProperty::PVariable) {
                    RealVariable& lvar = *storage.realVar;
                    ENUMERATE_ITEM (iitem, group) {
                      lvar[iitem] = var[iitem];
                    }
                  }
                  else {
                    std::shared_ptr<RealVariable>& lvar = storage.realVar;
                    if (lvar) {
                      if (lvar->variable() != var.variable()) {
                        // change reference to allItems container
                        lvar.reset(new RealVariable(var));
                      }
                      // else nothing to copy; already well referenced
                    }
                    else {
                      // new reference on allItems container
                      lvar.reset(new RealVariable(var));
                    }
                  }
                }

                // Need ItemGroupMap storage for that property ?
                group_property.computed |= property;
                group_property.delegated |= property;
              }
              else {
                ARCANE_ASSERT((IGeometryProperty::isVectorial(property)), ("Vectorial property expected"));
                Real3Variable& var = *all_group_property.storages[property].real3Var;

                // Need Variable storage for that property ?
                if (storage.storageType & IGeometryProperty::PVariable) {
                  if (storage.externStorage & IGeometryProperty::PVariable) {
                    Real3Variable& lvar = *storage.real3Var;
                    ENUMERATE_ITEM (iitem, group) {
                      lvar[iitem] = var[iitem];
                    }
                  }
                  else {
                    std::shared_ptr<Real3Variable>& lvar = storage.real3Var;
                    if (lvar) {
                      if (lvar->variable() != var.variable()) {
                        // change reference to allItems container
                        lvar.reset(new Real3Variable(var));
                      }
                      // else nothing to copy; already well referenced
                    }
                    else {
                      // new reference on allItems container
                      lvar.reset(new Real3Variable(var));
                    }
                  }
                }

                // Need ItemGroupMap storage for that property ?
                group_property.computed |= property;
                group_property.delegated |= property;
              }
            }
          }
        }
      }
    }
  }

  // Mise à jour des autres propriétés
  for (PropertyMap::iterator iprop = m_group_property_map.begin(); iprop != m_group_property_map.end(); ++iprop) {
    update(iprop->first);
  }
}

void GeometryServiceBase::
reset()
{
  for (PropertyMap::iterator iprop = m_group_property_map.begin(); iprop != m_group_property_map.end(); ++iprop) {
    reset(iprop->first);
  }
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ItemGroupGeometryProperty::StorageInfo&
GeometryServiceBase::_checkItemGroupProperty(ItemGroupImpl* group,
                                             IGeometryProperty::eProperty property,
                                             IGeometryProperty::eStorage storage)
{
  PropertyMap::iterator iprop = m_group_property_map.find(group);
  if (iprop == m_group_property_map.end())
    ARCANE_FATAL("Non declare group {0}", group->name());
  ItemGroupGeometryProperty& properties = iprop->second;
  if ((properties.defined & property) != property)
    ARCANE_FATAL("Non available property [{0}] requested from group {1}",
                 IGeometryProperty::name(property), group->name());
  ItemGroupGeometryProperty::StorageInfo& storages = properties.storages[property];
  if ((storages.storageType & storage) != storage)
    ARCANE_FATAL("Non available storage [{0}] requested for property {1} on group {2}",
                 IGeometryProperty::name(storage), IGeometryProperty::name(property), group->name());
  return storages;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void GeometryServiceBase::_resetComputeFlags()
{
  for (PropertyMap::iterator igroup = m_group_property_map.begin(); igroup != m_group_property_map.end(); ++igroup) {
    ItemGroupGeometryProperty& group_property = igroup->second;
    group_property.resetFlags();
  }
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void GeometryServiceBase::_checkItemGroupUsage()
{
  // Control that all extern storage are not shared !
  typedef std::map<const IVariable*, std::pair<ItemGroupImpl*, IGeometryProperty::eProperty>> ExternVariables;
  ExternVariables extern_variables;

  for (PropertyMap::iterator igroup = m_group_property_map.begin(); igroup != m_group_property_map.end(); ++igroup) {
    ItemGroupGeometryProperty& group_property = igroup->second;
    for (ItemGroupGeometryProperty::StorageInfos::const_iterator i = group_property.storages.begin();
         i != group_property.storages.end(); ++i) {
      const IGeometryProperty::eProperty property = i->first;
      const ItemGroupGeometryProperty::StorageInfo& info = i->second;
      if (info.usageVarCount == 0 && (info.realVar || info.real3Var) && !(info.externStorage & IGeometryProperty::PVariable))
        traceMng()->warning() << "Geometric property " << IGeometryProperty::name(property)
                              << " on group " << igroup->first->name() << " with Variable storage never used since last update";

      // Check non shared extern Variable storage
      if (info.realVar || (info.real3Var && (info.externStorage & IGeometryProperty::PVariable))) {
        IVariable* check_variable = NULL;
        if (info.realVar) {
          check_variable = info.realVar->variable();
        }
        if (info.real3Var) {
          ARCANE_ASSERT((check_variable == NULL), ("Inconsistent real/real3 storage"));
          check_variable = info.real3Var->variable();
        }
        std::map<const IVariable*, std::pair<ItemGroupImpl*, IGeometryProperty::eProperty>>::const_iterator finder = extern_variables.find(check_variable);
        if (finder != extern_variables.end()) {
          traceMng()->warning() << "Geometric property " << IGeometryProperty::name(property)
                                << " on group " << igroup->first->name() 
                                << " shares extern Variable " << finder->first->name()
                                << " with property " << IGeometryProperty::name(finder->second.second) 
                                << " on group " << finder->second.first->name();
        }
        else {
          extern_variables[check_variable] = std::make_pair(igroup->first, property);
        }
      }
    }
  }
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

NUMERICS_END_NAMESPACE
ARCANE_END_NAMESPACE
