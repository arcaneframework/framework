// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
#include <arcane/geometry/euclidian/Euclidian3GeometryService.h>
/* Author : havep at Wed Nov 14 13:55:36 2007
 * Generated by createNew
 */

#include <arcane/IMesh.h>
#include <arcane/IMeshSubMeshTransition.h>
#include <arcane/IItemFamily.h>
using namespace Arcane;

#include <arcane/geometry/euclidian/Euclidian3Geometry.h>

ARCANE_BEGIN_NAMESPACE
NUMERICS_BEGIN_NAMESPACE

/* Few words about possible optimisations:
 * Next possible optimizations (when necessary) are:
 * - Compute common properties on maximal group 
 *   (instead of re-computing the same property on all groups with shared items)
 * - Different properties may use the same computation. Then, maximal group factorisation
 *   may consider by a system of "what properties may compute this kernel" even if not
 *   shared by alls group in a maximal set.
 * - Mandatory storage parameter in addItemGroupProperty (up to now, this is optional)
 * - Geometry computations by constraints
 *   ex: for volume computations, we need face center on Quad4. This center is computed twice 
 *       for each shared face. Moreover, this computation may be also wished by the used.
 *  The idea is to define requirements for each geometry computations by kind and type.
 *  Then computations are done following the order of the weakest constraints.
 */

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

Euclidian3GeometryService::
Euclidian3GeometryService(const Arcane::ServiceBuildInfo & sbi) : 
  ArcaneEuclidian3GeometryObject(sbi),
  GeometryServiceBase(),
  m_geometry(NULL)
{
  ;
}

Euclidian3GeometryService::
~Euclidian3GeometryService()
{
  if (m_geometry) 
    delete m_geometry;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void 
Euclidian3GeometryService::
init()
{
  if (m_geometry)
    {
      info() << className() << " already initialized";
      return;
    }

  // L'implémentation actuelle se construit sur le maillage par défaut
  m_geometry = new Euclidian3Geometry(PRIMARYMESH_CAST(this->mesh())->nodesCoordinates());

  if (options()->variableSuffix.size() > 0)
    {
      setSuffix(options()->variableSuffix[0]);
    }
}

/*---------------------------------------------------------------------------*/

void 
Euclidian3GeometryService::
update(ItemGroup group)
{
  updateGroup(group,*m_geometry);
}

void 
Euclidian3GeometryService::
reset(ItemGroup group)
{
  ARCANE_UNUSED(group);
}
  
/*---------------------------------------------------------------------------*/

 
/*---------------------------------------------------------------------------*/

IGeometry *
Euclidian3GeometryService::
geometry()
{
  return m_geometry;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ARCANE_REGISTER_SERVICE_EUCLIDIAN3GEOMETRY(Euclidian3Geometry,Euclidian3GeometryService);

NUMERICS_END_NAMESPACE
ARCANE_END_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
