// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------

/* Author : havep at Wed Nov 14 13:29:24 2007
 * Generated by createNew
 */

#include <boost/shared_ptr.hpp>

#include <arcane/BasicUnitTest.h>

#include <arcane/tests/ArcaneTestGlobal.h>

#include <arcane/geometry/IGeometry.h>
#include <arcane/geometry/IGeometryMng.h>
#include <arcane/discreteoperator/IDivKGradDiscreteOperator.h>

using namespace Arcane::Numerics;
#include "arcane/tests/discreteoperator/DiscreteOperatorUnitTest_axl.h"

#include <arcane/ITimeLoopMng.h>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ARCANETEST_BEGIN_NAMESPACE


using namespace Arcane;

class DiscreteOperatorUnitTest
  : public ArcaneDiscreteOperatorUnitTestObject
{
public:
  /** Constructeur de la classe */
  DiscreteOperatorUnitTest(const ServiceBuildInfo& cb)
    : ArcaneDiscreteOperatorUnitTestObject(cb)
  {
    ;
  }

  /** Destructeur de la classe */
  virtual ~DiscreteOperatorUnitTest() {}
  
public:
  virtual void initializeTest();
  virtual void executeTest();

  /** Retourne le numéro de version du module */
  virtual Arcane::VersionInfo versionInfo() const { return Arcane::VersionInfo(1,0,0); }

private:
  // Discrete operator
  IDivKGradDiscreteOperator * m_op;

  // Geometric service
  IGeometryMng * m_geom;

  // Permeabilities
  boost::shared_ptr<VariableCellReal> m_k;
  boost::shared_ptr<VariableCellReal3> m_k3;
  boost::shared_ptr<VariableCellReal3x3> m_k3x3;

  // Face groupss
  boost::shared_ptr<FaceGroup> m_internal_faces;
  boost::shared_ptr<FaceGroup> m_boundary_faces;

};

void 
DiscreteOperatorUnitTest::
initializeTest()
{
  // Initialize services
  info() << "Initializing services";
  m_geom = options()->geometryService();
  m_op = options()->op();  

  m_geom->init();
  m_op->init();

  m_op->setGeometryService(m_geom);

  // Initialize diffusion 
  info() << "Initializing diffusion coefficient";
  VariableBuildInfo vb(allCells().mesh(), "k", IVariable::PPrivate|IVariable::PTemporary);
  m_k.reset(new VariableCellReal(vb));

  Real    kT = 1;
  ENUMERATE_CELL(iT, allCells()) {
    (*m_k)[*iT] = kT;
  }

  // Create face groups  
  info() << "Creating face groups";
  m_internal_faces.reset(new FaceGroup(subDomain()->mesh()->allCells().innerFaceGroup()));
  m_boundary_faces.reset(new FaceGroup(subDomain()->mesh()->allCells().outerFaceGroup()));
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void 
DiscreteOperatorUnitTest::
executeTest()
{
  // Prepare coefficient containers
  info() << "Preparing coefficient containers";
  CoefficientArrayT<Cell> cell_coefficients(allFaces(), allCells());
  CoefficientArrayT<Face> face_coefficients(allFaces(), *m_boundary_faces);

  // Prepare containers
  FaceGroup c_internal_faces  = m_internal_faces->itemFamily()->createGroup("C_INTERNAL_FACES");
  FaceGroup cf_internal_faces = m_internal_faces->itemFamily()->createGroup("CF_INTERNAL_FACES");

  // Prepare the operator
  info() << "Preparing discrete operator";
  m_op->prepare(*m_internal_faces,
                *m_boundary_faces,
                c_internal_faces,
                cf_internal_faces,
                &cell_coefficients,
                &face_coefficients);

  // Compute relevant geometric properties
  info() << "Computing geometric data";
  m_geom->addItemGroupProperty(m_op->cells(), m_op->getCellGeometricProperties());
  m_geom->addItemGroupProperty(m_op->faces(), m_op->getFaceGeometricProperties());
  m_geom->update();

  // Form discrete operator
  info() << "Forming discrete operator";
  m_op->formDiscreteOperator(*m_k);

  // Print coefficients
  info() << "Cell coefficients";
  cell_coefficients.print(info());
  info() << "Face coefficients";
  face_coefficients.print(info());

  // Exit the loop
  subDomain()->timeLoopMng()->stopComputeLoop(true);
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ARCANE_REGISTER_SERVICE_DISCRETEOPERATORUNITTEST(DiscreteOperatorUnitTest,DiscreteOperatorUnitTest);


ARCANETEST_END_NAMESPACE

