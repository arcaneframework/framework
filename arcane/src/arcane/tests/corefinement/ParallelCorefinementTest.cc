// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
/* Author : havep at Wed Feb 18 14:17:55 2009
 * Generated by createNew
 */

#include <arcane/BasicUnitTest.h>
#include <arcane/corefinement/IParallelCorefinement.h>
#include <arcane/tests/corefinement/ParallelCorefinementTest_axl.h>
#include <arcane/IMeshSubMeshTransition.h>
#include <arcane/IMeshModifier.h>

ARCANE_BEGIN_NAMESPACE
NUMERICS_BEGIN_NAMESPACE

class IGeometry;
class IParallelCorefinement;

NUMERICS_END_NAMESPACE
ARCANE_END_NAMESPACE

/*---------------------------------------------------------------------------*/

using namespace Arcane;
using namespace Arcane::Numerics;


class ParallelCorefinementTest :
  public ArcaneParallelCorefinementTestObject
{
public:
  /** Constructeur de la classe */
  ParallelCorefinementTest(const Arcane::ServiceBuildInfo & sbi);
  
  /** Destructeur de la classe */
  virtual ~ParallelCorefinementTest();
  
public:
  /** Retourne le numéro de version du module */
  virtual Arcane::VersionInfo versionInfo() const { return Arcane::VersionInfo(1,0,0); }

  void initializeTest();
  void executeTest();
  void finalizeTest();

private:
  FaceGroup m_master_group;
  FaceGroup m_slave_group;
  IParallelCorefinement * m_corefinement;
  IGeometry * m_geometry;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#include <arcane/corefinement/IParallelCorefinement.h>
#include <arcane/tests/corefinement/ParallelCorefinementTest_axl.h>

#include <arcane/IMesh.h>
#include <arcane/Properties.h>
#include <arcane/ITimeLoopMng.h>
#include <arcane/IItemFamily.h>
#include <arcane/ItemPrinter.h>
#include <arcane/IParallelMng.h>

#include <arcane/corefinement/IParallelCorefinement.h>
#include <arcane/geometry/ItemGroupBuilder.h>
#include <arcane/geometry/IGeometry.h>
#include <arcane/geometry/euclidian/Euclidian3Geometry.h>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ParallelCorefinementTest::
ParallelCorefinementTest(const Arcane::ServiceBuildInfo& mbi)
  : ArcaneParallelCorefinementTestObject(mbi),
    m_corefinement(NULL),
    m_geometry(NULL)
{
  ;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ParallelCorefinementTest::
~ParallelCorefinementTest()
{
  delete m_geometry;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void 
ParallelCorefinementTest::
initializeTest()
{
  info() << "init";
  mesh()->modifier()->setDynamic(true); // permet de modifier le maillage pour le coraffinement
  m_master_group = mesh()->faceFamily()->findGroup(options()->master(),true);
  m_slave_group = mesh()->faceFamily()->findGroup(options()->slave(),true);
  m_corefinement = options()->corefinement();
  m_geometry = new Euclidian3Geometry(PRIMARYMESH_CAST(mesh())->nodesCoordinates());
  m_corefinement->init(m_master_group,m_slave_group,options()->boxTolerance(),m_geometry);

  if (options()->xyMasterShift() != 0) {
    const Real shift = options()->xyMasterShift();
    ItemGroupBuilder<Node> node_builder(mesh(),"MasterNodes");
    ENUMERATE_FACE(iface,m_master_group) {
      node_builder.add(iface->nodes());
    }
    NodeGroup master_nodes = node_builder.buildGroup();
    
    VariableNodeReal3 & coords = PRIMARYMESH_CAST(mesh())->nodesCoordinates();
    ENUMERATE_NODE(inode,master_nodes)
      {
        coords[inode].x += shift;
        coords[inode].y += shift;
      }
  }
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class Tester {
private:
  ParallelCorefinementTest * m;
  IGeometry * geometry;
public:
  Tester(ParallelCorefinementTest * _m, IGeometry * _geometry) : m(_m), geometry(_geometry) { }
  void run(const ISurfaceUtils::FaceFaceContactList & contacts, const Integer testid, const String testname) {
    Real3 AsumXYZ, BsumXYZ;
    Integer big_contact_count = 0;
    for(Integer i=0; i<contacts.size(); ++i) {
      const ISurfaceUtils::FaceFaceContact & contact = contacts[i];
      bool test = false;
      switch (testid) {
      case 1:  // faceface contact
        test = (not contact.faceA.null() and contact.faceA.isOwn() and not contact.faceB.null());
//         if (test)
//           std::cout << "Global co-ref contact : " << contact.faceA.uniqueId() << " " << contact.faceA.owner() << " "  << contact.faceB.uniqueId() << " " << contact.faceB.owner() << " "  << contact.normalA << " "  << contact.normalB <<" [" << i << "]\n";
        break;
      case 2:  // facevoid contact
        test = (not contact.faceA.null() and contact.faceA.isOwn() and contact.faceB.null());
//         if (test)
//           std::cout << "Global co-ref contact : " << contact.faceA.uniqueId() << " " << contact.faceA.owner() << " null "  << contact.normalA << " "  << contact.normalB <<" [" << i << "]\n";
        break;
      case 3:  // voidface contact
        test = (contact.faceA.null() and not contact.faceB.null() and contact.faceB.isOwn());
//         if (test)
//           std::cout << "Global co-ref contact : null "  << contact.faceB.uniqueId() << " " << contact.faceB.owner() << " "  << contact.normalB << " " << math::normeR3(geometry->computeOrientedMeasure(contact.faceB)) <<" [" << i << "]\n";
        break;
      }
      if (test)
        {
          AsumXYZ += contact.normalA;
          BsumXYZ += contact.normalB;
          ++big_contact_count;
        }
    }
      
    UniqueArray<Real> __normals(6);
    __normals[0] = AsumXYZ.x; __normals[1] = AsumXYZ.y; __normals[2] = AsumXYZ.z;
    __normals[3] = BsumXYZ.x; __normals[4] = BsumXYZ.y; __normals[5] = BsumXYZ.z;
    m->subDomain()->parallelMng()->reduce(Parallel::ReduceSum,__normals);
    AsumXYZ.x = __normals[0]; AsumXYZ.y = __normals[1]; AsumXYZ.z = __normals[2];
    BsumXYZ.x = __normals[3]; BsumXYZ.y = __normals[4]; BsumXYZ.z = __normals[5];
      
    big_contact_count = m->subDomain()->parallelMng()->reduce(Parallel::ReduceSum,big_contact_count);
      
    m->traceMng()->pinfo() << "Global co-refinement " << testname << " infos : " << big_contact_count << " : " << AsumXYZ << " " << BsumXYZ;
  }
};

/*---------------------------------------------------------------------------*/

void 
ParallelCorefinementTest::
executeTest()
{  
  m_contact_ratio.fill(0.);
  m_contact_void_ratio.fill(0.);
  m_contact_count.fill(0);

  m_corefinement->update();
  const IParallelCorefinement::FaceFaceContactList & contacts = m_corefinement->contacts();
  pinfo() << "Local co-refinement size : " << contacts.size();

  // *- Tests complémentaires d'intégrité
  Real3 normalA_coref(0,0,0), normalA_local(0,0,0);
  Real3 normalB_coref(0,0,0), normalB_local(0,0,0);

  ENUMERATE_FACE(iface,m_master_group.own())
    normalA_local += m_geometry->computeOrientedMeasure(*iface);
  ENUMERATE_FACE(iface,m_slave_group.own())
    normalB_local += m_geometry->computeOrientedMeasure(*iface);

  for(Integer i=0; i<contacts.size(); ++i) {
    const ISurfaceUtils::FaceFaceContact & contact = contacts[i];
    const Face faceA = contact.faceA;
    const Face faceB = contact.faceB;
    if (not faceA.null() and faceA.isOwn()) 
      {
        const Cell cellA = faceA.boundaryCell();
        normalA_coref += contact.normalA;
        m_contact_count[cellA] += 1;
        const Real ratio = contact.normalA.abs() / m_geometry->computeOrientedMeasure(faceA).abs();
        if (faceB.null())
          m_contact_void_ratio[cellA] += ratio;
        else
          m_contact_ratio[cellA] += ratio;
      }
    if (not faceB.null() and faceB.isOwn())
      {
        const Cell cellB = faceB.boundaryCell();
        // info() << "Global co-ref contact : " << ItemPrinter(contact.faceA) << " " << ItemPrinter(contact.faceB) << " " << math::normeR3(contact.normalB);
        normalB_coref += contact.normalB;
        m_contact_count[cellB] += 1;
        const Real ratio = contact.normalA.abs() / m_geometry->computeOrientedMeasure(faceB).abs();
        if (faceA.null())
          m_contact_void_ratio[cellB] += ratio;
        else
          m_contact_ratio[cellB] += ratio;
      }
  }

  UniqueArray<Real> __normals(12);
  __normals[ 0] = normalA_coref.x; __normals[ 1] = normalA_coref.y; __normals[ 2] = normalA_coref.z;
  __normals[ 3] = normalA_local.x; __normals[ 4] = normalA_local.y; __normals[ 5] = normalA_local.z;
  __normals[ 6] = normalB_coref.x; __normals[ 7] = normalB_coref.y; __normals[ 8] = normalB_coref.z;
  __normals[ 9] = normalB_local.x; __normals[10] = normalB_local.y; __normals[11] = normalB_local.z;
  subDomain()->parallelMng()->reduce(Parallel::ReduceSum,__normals);
  normalA_coref.x = __normals[ 0]; normalA_coref.y = __normals[ 1]; normalA_coref.z = __normals[ 2];
  normalA_local.x = __normals[ 3]; normalA_local.y = __normals[ 4]; normalA_local.z = __normals[ 5];
  normalB_coref.x = __normals[ 6]; normalB_coref.y = __normals[ 7]; normalB_coref.z = __normals[ 8];
  normalB_local.x = __normals[ 9]; normalB_local.y = __normals[10]; normalB_local.z = __normals[11];

  const Real Aerror = math::abs(math::normeR3(normalA_coref)-math::normeR3(normalA_local))/math::normeR3(normalA_local);
  const Real Berror = math::abs(math::normeR3(normalB_coref)-math::normeR3(normalB_local))/math::normeR3(normalB_local);

  info() << "Global co-refinement stats : " 
         << math::normeR3(normalA_coref) << " vs " <<  math::normeR3(normalA_local) << " (error=" << Aerror << ") ; "
         << math::normeR3(normalB_coref) << " vs " <<  math::normeR3(normalB_local) << " (error=" << Berror << ")";

  if (Aerror > 1e-9 or Berror > 1e-9)
    fatal() << "Not integral co-refinement";

  Tester tester(this,m_geometry); 
  tester.run(contacts,1,"FaceFace");
  tester.run(contacts,2,"FaceVoid");
  tester.run(contacts,3,"VoidFace");

  subDomain()->timeLoopMng()->stopComputeLoop(false);      
}

/*---------------------------------------------------------------------------*/

void 
ParallelCorefinementTest::
finalizeTest()
{
  ;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ARCANE_REGISTER_SERVICE_PARALLELCOREFINEMENTTEST(ParallelCorefinementTest,ParallelCorefinementTest);
