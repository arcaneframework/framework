// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
#include "GeometryKernelSurfaceInternalUtils.h"
/* Author : havep at Wed Apr  1 14:31:35 2009
 * Generated by createNew
 */

#include <arcane/utils/NotImplementedException.h>
#include <GeometryKernel/tools/surface/triangulation-topo-tools.h>

ARCANE_BEGIN_NAMESPACE
NUMERICS_BEGIN_NAMESPACE
using namespace Arcane;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void buildFaceGroupSurface(FaceGroup group, 
                           GeometryKernel::TriangulationDataStructurePtr surface,
                           Array<Node> & node_array,
                           Array<Face> & face_array,
                           Array<bool> & face_reorient,
                           Real3 & normal)
{  
  surface->clear();
  face_array.clear();
  face_array.reserve(group.size()); // au moins un par face
  node_array.clear();
  normal = Real3(0.,0.,0.);

  NodeMapping nodeMapping(group.mesh(),node_array,*surface);

  ENUMERATE_FACE(iface,group) {
    const Face & face = *iface;
    const Real face_factor = ((face.isBoundaryOutside())?1:-1);
    switch (face.type()) {
    case IT_Triangle3:
      surface->newFace(nodeMapping.getNodeId(face.node(0)),
                       nodeMapping.getNodeId(face.node(1)),
                       nodeMapping.getNodeId(face.node(2)));
      face_array.add(face);
      if (face.isOwn())
        normal += face_factor*nodeMapping.computeNormal(face.node(0), face.node(1), face.node(2));
      break;
    case IT_Quad4:
      surface->newFace(nodeMapping.getNodeId(face.node(0)),
                      nodeMapping.getNodeId(face.node(1)),
                      nodeMapping.getNodeId(face.node(2)));
      face_array.add(face);
      if (face.isOwn())
        normal += face_factor*nodeMapping.computeNormal(face.node(0), face.node(1), face.node(2));
      surface->newFace(nodeMapping.getNodeId(face.node(2)),
                      nodeMapping.getNodeId(face.node(3)),
                      nodeMapping.getNodeId(face.node(0)));
      face_array.add(face);
      if (face.isOwn())
        normal += face_factor*nodeMapping.computeNormal(face.node(2), face.node(3), face.node(0));
      break;
    default:
      throw NotImplementedException(A_FUNCINFO,"Non Tri3 or Quad4 face type");
    }
  }

  // Orientation de la surface et sauvegarde des changements d'orientation
  GeometryKernel::TriangulationTopoTools topology(*surface);
  face_reorient.resize(face_array.size());
  topology.computeMicroTopology(face_reorient.begin(),face_reorient.end());
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void saveSurface(const char * filename, GeometryKernel::TriangulationDataStructure & tr)
{
  typedef GeometryKernel::Vector Vector;
  typedef GeometryKernel::TriangulationFace Face;
  typedef GeometryKernel::TObjectId TObjectId;

  std::ofstream file;
  file.open(filename,std::ios::out | std::ios::binary);
  const int nVertices = tr.numberOfVertices();
  file.write((const char*)&nVertices,sizeof(int));
  for(Integer i=0;i<nVertices;++i)
    {
      const Vector & point = tr.vertex(i).point();
      file.write((const char*)&point,sizeof(Vector));
    }
  const int nFaces = tr.numberOfFaces();
  file.write((const char*)&nFaces,sizeof(int));
  for(Integer i=0;i<nFaces;++i)
    {
      const Face & face = tr.face(i);
      for(int j=0;j<3;++j) {
        const TObjectId k = face.vertex(j);
        file.write((const char*)&k,sizeof(TObjectId));
      }
    }
  file.close();
}

/*---------------------------------------------------------------------------*/

void loadSurface(const char * filename, GeometryKernel::TriangulationDataStructure & tr)
{
  typedef GeometryKernel::Vector Vector;
  typedef GeometryKernel::TriangulationFace Face;
  typedef GeometryKernel::TObjectId TObjectId;

  tr.clear();

  std::ifstream file;
  file.open(filename,std::ios::in | std::ios::binary);
  int nVertices;
  file.read((char*)&nVertices,sizeof(int));
  for(Integer i=0;i<nVertices;++i)
    {
      Vector point;
      file.read((char*)&point,sizeof(Vector));
      tr.newVertex(point);
    }
  int nFaces;
  file.read((char*)&nFaces,sizeof(int));
  for(Integer i=0;i<nFaces;++i)
    {
      TObjectId k[3];
      for(int j=0;j<3;++j) {
        file.read((char*)&k[j],sizeof(TObjectId));
      }
      tr.newFace(k[0],k[1],k[2]);
    }
  file.close();
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

NUMERICS_END_NAMESPACE
ARCANE_END_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

